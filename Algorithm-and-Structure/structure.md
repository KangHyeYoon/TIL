# 코드의 품질

코드를 동작시키는 것은 프로그래밍에 있어 가장 원초적이며 근본적인 목표이다. 그러나 프로그래머라면 같은 동작을 하는(같은 일을 하는) 코드더라도 보다 더 나은 코드를 작성하고 싶어진다. `코드의 품질`은 크게 두 가지에 의해 결정된다.

1. 유지 보수성 (가독성, 조직, 모듈성 등)
2. **효율성**

어떤 것이 더 효율적인 코드일까? 한 번 맛보기로 예시를 들어보겠다.

```jsx
// 2~100 사이 짝수 출력 프로그램

// 1
// 루프 100번 돈다 : 비효율적
function even1() {
    let num = 2;
    while(true) {
        if (num%2 === 0) {
            console.log(num);
        }
        num++;
        if (num>100) break;
    }
}

even1();

console.log(`\n===============================\n`);

// 2
// 루프 50번 돈다 : 효율적
function even2() {
    let num = 2;
    while(true) {
        console.log(num);
        num += 2;
        if (num>100) break;
    }
}

even2();
```

- even1()

1~100까지 ++ 연산을 통해 100번 순회한다. 2로 나눴을 경우 나머지가 0인 경우만 출력하는 식으로 짝수를 반환한다

- even2()

1~100까지 +=2 연산을 통해 **50번** 순회한다. 짝수의 정의를 다른 관점에서 바라보면, 굳이 모든 수에서 2로 나눠 나머지가 0인 수를 걸러내는 방법보다 그냥 2씩 더해주면 되는 것이다!

# 자료구조

> `데이터`를 `조직`하는 방법
> 

데이터를 어떻게 조직하느냐(어떤 자료구조를 선택하느냐)는 `코드의 실행 속도`에 큰 영향을 미친다. 우리는 다양한 자료 구조를 알고 개발중인 프로그램의 성능에 어떤 영향을 미칠지 확실히 알아야 한다.

# 연산 속도 측정에 대하여

> 연산이 얼마나 *빠른가*에 대한 측정은 ~~시간~~이 아니라 **단계**에서 결정된다.
> 
- 시간 : HW의 성능에 따라 달라지므로 신뢰할 수 없다
- 단계 : 얼마나 많은 계산 단계(step)가 필요한지를 따져보면 유용하다.

연산 속도 = 시간 복잡도 = 효율성 = 성능

👉 **지금부터 `배열과 집합`의 `연산 속도`를 `단계`로 측정해보겠다.**


# 자료구조의 연산 : 배열

## 읽기

> 자료 구조 내 특정 위치를 찾는다.
> 

in 배열 : 특정 인덱스의 값을 찾는다. ex) 인덱스 2에 들어있는 요소를 참조한다

## 검색

> 자료 구조 내 특정 값을 찾는다.
> 

in 배열 : 어떤 요소가 배열 내에 있는지, 있다면 어떤 인덱스에 있는지 찾는다.

## 삽입

> 자료 구조에 새로운 값을 추가한다.
> 

in 배열 : 메모리 공간을 더 만들어 그 안에 새 값을 추가한다.

## 삭제

> 자료 구조에서 값을 제거한다.
> 

in 배열 : 배열의 값 중 하나를 제거한다.

## 읽기

> 컴퓨터는 `단 한 번의 단계`만으로 배열 내 특정 인덱스의 값을 불러올 수 있다.
> 

컴퓨터는 다음과 같은 특징을 가진다.

1. 모든 메모리 주소에 단 한 번에 접근 가능
2. 배열을 할당할 때, 메모리 시작 주소를 기억
3. 배열의 크기도 기억

EX) 인덱스 3에 들어있는 값은 무엇인가?

1. 컴퓨터는 인덱스0(시작 주소)의 메모리 주소를 알고 있다 : 1010
2. 거기에 +3(인덱스)를 더해 준다 : 1013
3. 1013 주소에 단 한 번의 단계만으로 바로 접근한다.

단 한 번의 단계 → 효율적!

## 검색

> 배열에 특정 값이 있는지 알아본 후, 있다면 어느 인덱스에 있는지(`1 ~ N 단계`) 찾는다.
> 

## 읽기 vs 검색

- 읽기 : 인덱스 제공 → 그 인덱스에 들어있는 값을 반환할 것을 요청
- 검색 : 값 제공 → 그 값이 들어있는 인덱스를 반환하라고 요청

**컴퓨터는 모든 메모리 주소에 한 번에 접근하지만(읽기), 각 메모리 주소에 어떤 값이 있는지는 바로 알지 못하므로 하나하나 순차적으로 찾아줘야 한다.(검색)**

이러한 검색 방법을 `선형 검색`이라고 한다. 운 좋게 첫 번째 메모리에서 값을 찾으면 단 한 번의 단계에서 끝나겠지만, 만약 맨 끝 메모리에서 찾게 된다면 N 번의 단계를 거치게 된다.

1~N번의 단계 → 읽기보다는 덜 효율적!

## 삽입

> 삽입은 1. 삽입할 공간을 위해 데이터를 이동시키는 단계(1~N)와 2. 실제 삽입을 하는 단계(1)로 이루어지기 때문에 최대 `N+1`의 단계를 갖는다.
> 

배열의 **어디에** 데이터를 삽입하느냐에 따라 효율성이 크게 달라진다.

1. **맨 끝**에 추가하는 경우

컴퓨터는 배열의 `메모리 시작 주소`와 배열의 `크기`를 기억한다

→ 단 한 번의 단계(메모리 추가+요소 추가)로 추가 가능

1. **중간**이나 **맨 처음**에 추가하는 경우

먼저 삽입할 공간을 만들기 위해 데이터를 순차적으로 옮겨줘야 하고, 그 후에 삽입 단계가 이루어진다.

1~N+1번의 단계

## 삭제

> 삭제는 1. 실제 삭제를 하는 단계(1)와 2. 삭제로 인해 생긴 빈 공간들을 메꾸는 단계(N-1)로 이루어지기 때문에 최대 `N`의 단계를 갖는다.
> 

삭제를 하면 배열에 빈 공간이 생기는데, 이는 비효율적이므로 남아있는 모든 원소를 하나씩 순차적으로 옮겨서 메꾸개 된다.

1~N번의 단계

# 집합

> `중복` 값을 **허용하지 않는** 자료구조
> 

다양한 집합 中 배열 기반 집합은 값들의 단순 리스트로 배열과 거의 비슷하지만 중복을 허용하지 않는다는 제약이 있다.

- 읽기 : 배열과 똑같다. 1 단계
- 검색 : 배열과 똑같다. 최대 N 단계
- 삭제 : 배열과 똑같다. 최대 N 단계

## 삽입

*그러나 `삽입`은...*

> 집합은 중복을 허용하지 않으므로, 일단 집합에서 “삽입하고자 하는 데이터”가 이미 존재하는지부터 **검색**해야 한다. → 최대 `2N+1` 단계
> 

즉, 삽입 하기 전 중복 방지를 위한 `검색`이 먼저이다.

- 맨 끝에 삽입하는 경우
1. 순차적 검색 : 1~N 단계
2. 실제 삽입 : 1 단계

—> N + 1 단계

- 맨 앞(최악의 시나리오)에 삽입하는 경우
1. 순차적 검색 : 1 ~ N 단계
2. 데이터 하나씩 옮겨서 삽입할 빈 자리 만들기 : N 단계
3. 실제 삽입 : 1 단계

—> **`2N + 1` 단계**

위에서 살펴봤듯이, 집합은 일반적인 배열보다 삽입이 느리지만(단계가 상대적으로 많아 효율성이 떨어지지만) 중복이 없어야 하는 경우 사용한다.
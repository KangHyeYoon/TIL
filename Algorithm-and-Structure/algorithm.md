# 알고리즘

`알고리즘`은 특정 과제를 완수하는 명령어의 집합으로 알고리즘의 적절한 선택은 코드의 성능을 높인다. ([전 내용](https://github.com/KangHyeYoon/TIL/blob/main/Algorithm-and-Structure/structure.md)에서 보았던 짝수를 출력하는 두 가지 방식처럼, 어떤 알고리즘은 나머지 알고리즘에 비해 단계가 두 배나 빠를 수 있다.)

같은 문제를 해결하는 두 알고리즘 예제를 통해 알고리즘의 필요성에 대해 알아보자.

# 정렬된 배열 (Ordered Array)

`정렬된 배열` 이 *전형적인*  배열과 다른 점은, **값이 항상 순서대로 정렬**되어 있다는 것이다. (값이 추가될 때 ‘정렬된 상태’가 유지되도록 적절한 메모리에 삽입된다)

## 삽입

### 1. 값이 들어갈 올바른 위치를 검색

1. 인덱스 0의 값을 확인하고, 삽입하려는 값이 그 값을 기준으로 왼쪽으로 들어가야 할지 오른쪽으로 들어가야 할지 위치를 결정한다.
2. 다음 메모리로 이동하며 이 동작을 반복한다.

### 2. 데이터 이동

검색을 완료한 후, 올바른 위치에 값을 삽입하기 위해 순차적으로 데이터를 이동시킨다.

### 3. 실제 삽입

올바른 위치에 값을 삽입한다.

![ordered-array](https://user-images.githubusercontent.com/97890886/166144595-59018c58-247a-453f-a208-f08e1dfe4c36.png)

이 때 값의 위치와 무관하게 앞 두 단계의 합은 유지된다. 비교(검색)와 이동이 마치 보존 법칙처럼 상호작용하기 때문이다. 값을 넣을 위치가 앞 셀일수록 비교는 빨리 끝나지만 이동은 오래 걸리고, 뒷 셀일수록 비교는 오래 걸리지만 이동은 빠르다.

이 두 단계에서 최대 N+1단계가 소모되고, 삽입하는 데 1단계가 걸리므로 `N+1` ~ `N+2` 단계가 소모된다.

즉, 정렬된 배열은 삽입에 있어서 전형적 배열보다 덜 효율적이다. 그런데 왜 사용하는 걸까?

# 이진 검색 (Binary Search)

> 정렬된 배열은 `이진 검색`을 사용하여 전형적 배열보다 효율적인 검색이 가능하다.
> 

포커의 하이-로우 게임을 할 때나 랜덤 숫자 맞추기 게임을 할 때, 범위의 중간 값을 먼저 외치는 것이 확률적으로 이득이다. 이처럼 middle-point로 절반씩 버려가는 알고리즘이 바로 이진 검색이다.

![binary-search](https://user-images.githubusercontent.com/97890886/166144604-0910ca70-f01a-4101-b1df-665aa0a866c2.png)

## 정렬된 배열의 선형 검색

```jsx
// 정렬된 배열의 선형 검색

const arr = [1, 5, 12, 31, 99];

function arrSearch(array, searchValue) {
    // 배열의 모든 elements를 순회
    for (let i = 0; i<array.length; i++) {
        // 원하는 값을 찾으면 그 때의 index를 반환
        if (array[i] === searchValue) {
            return i;
        }
        // 원하는 값보다 큰 elements에 도달 시 루프 조기 종료
        else if (array[i] > searchValue) break;
    }
    // 배열에서 원하는 값을 찾지 못하면 null 반환
    return null;
}

console.log(arrSearch(arr, 12));    // 2
```

## 정렬된 배열의 이진 검색

```jsx
// 정렬된 배열의 이진 검색

function binarySearch(array, searchValue) {

    // 1. (인덱스) 상한선과 하한선 결정
    let upper = array.length - 1;
    let lower = 0;

    // 2. 상한선과 하한선 중간 지점 값을 계속해서 확인하는 루프
    // 상한선과 하한선 값이 같아지면 종료
    do {
        // 2-1. 중간 지점 값 확인
        let midPoint = (upper+lower) / 2;
        let valueMid = array[midPoint];

        // 2-2. 중간 지점 값이 찾고 있던 값이면 종료
        if (valueMid === searchValue) return midPoint;

        // 2-3. 아니면 추측한 바에 따라 상한선, 하한선 변경
        else if (valueMid > searchValue) upper = midPoint - 1;
        else if (valueMid < searchValue) lower = midPoint + 1 ;

      // 2-4. 상한선과 하한선 값이 같을 때까지 루프
    } while(upper>=lower);

    // 3. 상한선과 하한선 값이 같으면(루프가 종료되면)
    // 찾고 있는 값이 배열에 존재하지 않음을 의미
    return null;
}

arr1 = [1,24,30];
arr2 = [1,24,30,101,105,116];

console.log(binarySearch(arr1, 24));    // 1

// 참고 : 코드(알고리즘)는 맞지만, arr2는 정상적으로 동작하지 않는다
// 예제는 ruby로 쓰여 midpoint 값이 정수가 아니어도 자동으로 반올림되지만
// JS는 모든 number data가 부동소수점만을 따르기 때문에 코드가 제대로 수행되지 않는다
```

## 이진 검색의 강점

> 데이터를 두 배로 늘릴 때마다 이진 검색 알고리즘에서는 최대 `한 단계`만 추가된다.
> 

작은 크기의 정렬된 배열일 경우 선형 검색과 큰 차이가 없지만, 이진 검색의 진정한 가치는 큰 크기의 배열에서 드러난다.

### 이진 검색 VS 선형 검색


![binary-search2](https://user-images.githubusercontent.com/97890886/166144623-b4b65316-a68f-495a-ba15-525d2deb58b0.png)


→ `선형 검색`은 **요소 수만큼의 단계**가 필요하지만, `이진 검색`은 배열의 요소 수를 두 배로 늘릴 때마다 **한 단계만 늘어난다.** 값을 확인할 때마다 검색할 요소의 절반을 제거하니 이치에 맞는다. (데이터 2당 단계 1의 관계)

EX ) 1000개의 요소를 갖는 배열에서 특정 요소를 검색 :

- 선형 검색 : 1000 단계
- **이진 검색 : 10단계** (log2를 취하면 9.96...이 나옴)

이를 그래프로 표현하면 다음과 같다.


![binary-search3](https://user-images.githubusercontent.com/97890886/166144630-f4366cae-09e9-4ecb-82f8-76634ba0072e.png)


# 알고리즘의 필요성

특정 컴퓨팅 목표를 달성하는 방법은 대개 여러가지 있으며, 사용자가 선택하는 `알고리즘`이 코드의 속도에 큰 영향을 줄 수 있다. 모든 상황에 완벽하게 들어맞는 단 하나의 자료구조나 알고리즘은 존재하지 않으며(**은총알은 없다**) 상황에 따라 유동적으로 선택해야 한다.


![algorithm](https://user-images.githubusercontent.com/97890886/166144638-291d8c2a-e196-473c-b8a2-af17b7ff4b0d.png)

예를 들어, 정렬된 배열을 DB로 사용하는 프로그램에서 데이터를 삽입해야 한다고 치자. 이 때 삽입하려면 먼저 검색이 필요한데 이 검색을 선형 검색에서 이진 검색으로 업그레이드 할 수 있다. 데이터 검색은 거의 없고, 데이터를 추가하기만 한다면 아예 정렬되지 않은 전형적인 배열만 사용할 수 있다.
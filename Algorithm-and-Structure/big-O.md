# 알고리즘 성능을 비교하는 일관된 시스템

알고리즘의 `효율성`을 결정하는 주된 요인은 알고리즘 수행에 필요한 `단계`이다.  이를 어떻게 표기해야 할까? “22단계의 알고리즘”, “4단계의 알고리즘” 과 같이 정량화할 수는 없다. 특정 알고리즘에 필요한 단계 수를 단 하나의 수로 못박을 수는 없기 때문이다(애초에 처리할 데이터량이 일정하지 않다). 이 때 필요한 것이 바로 **빅 오 표기법**이다.

# 빅 오 표기법

> 데이터 원소가 *N개*일 때 알고리즘에 *몇 단계*가 필요한가?
> 

빅 오 표기법은 자료구조와 알고리즘의 효율성을 간결하게 수학적 개념으로 형식화한 것이다. 빅 오 표기법으로 앞에서 배운 알고리즘의 `시간 복잡도`를 표현해보자.

- O(N) -선형 시간(linear time) : [배열 선형 검색]에서는 데이터 원소가 N개일 때 N단계 필요
- O(1) - 상수 시간(constant time) : [배열 읽기]에서는 데이터 원소가 N개일 때 1단계 필요 (데이터 원소가 몇 개든 항상 상수 단계)

다음과 같이, 빅 오는 데이터 원소 N개에 대한 알고리즘의 단계 수이다. 그러나 이는 빅 오 표기법의 겉모습일 뿐, 본질은 아니다.

# 빅 오의 본질

위에서 배운 빅 오 표기법으로 “데이터가 몇개든 항상 3단계가 걸리는 알고리즘”을 표현해 보자.

→ O(3) 이라고 한다면, 틀렸다. **정답은 O(1)이다.** 이는 빅 오의 본질과 관련이 있다.

> **데이터가 늘어날 때 알고리즘의 성능(단계 수)은 어떻게 바뀌는가**가 빅 오의 본질이다.
> 

![bigO](https://user-images.githubusercontent.com/97890886/166230055-714baf41-fb2c-4da6-be03-2b1efea757d5.png)

즉 빅 오는 단순한 단계 수가 아닌, 데이터 량 증진에 따른 단계 수의 일반화이다.

- 이러한 관점에서 보면 O(3)과 O(1)은 다를 것이 없다. 둘 다 데이터 량 증가에 영향을 받지 않는(단계 수가 불변하는) 유형이기 때문이다.
- 같은 관점에서 O(N)을 해석해보면 데이터와 알고리즘의 효율성이 비례 관계로 영향을 받는 알고리즘이다.

## 빅 오의 본질의 중요성

알고리즘 성능 비교에 있어서 일관적이고 객관적인 정보를 제공한다.

![bigO2](https://user-images.githubusercontent.com/97890886/166230086-a2f58cf3-8394-43cd-8e4a-48b0d0e7aed8.png)

O(N)과 O(1) 중 누가 더 효율적인 알고리즘인지를 비교해보자.

100 이전에는 O(N)이 효율적이지만, **100보다 큰 보든 배열에서는 O(1)이 더 효율적이다.** 데이터가 증가할수록 O(N)이 O(1)보다 덜 효율적인 어느 지점(위 예시에서는 100)에 반드시 도달하게 되며, 이 순간부터 데이터 양이 무한대로 갈 때까지 이는 바뀌지 않는다.

## 빅 오 표기법은 “최악의 시나리오”

> 빅 오 표기법은 일반적으로 `최악의 시나리오`의 알고리즘 단계를 기준으로 한다.
> 

예를 들어 선형 검색의 경우, 빅 오 표기법으로 O(N)이지만 사실 이는 최악의 시나리오(찾고자 하는 값이 맨 마지막 셀에 존재할 때)이고 최선의 시나리오(찾고자 하는 값이 첫 번째 존재할 때)에서는 O(1)이다. 그러나 빅 오 표기법은 일반적으로 이를 O(N)로 퉁쳐서 표기한다.

→ *비관적인 접근*이 더 유용한 도구일 수 있다.

- 최악의 시나리오에서의 알고리즘의 비효율성을 알면 최악을 미리 대비할 수 있다.
- 이는 알고리즘 선택에 중요한 영향을 끼친다. (어떤 데이터를 선택할 때 어떤 최악을 피해야 하는지가 정해져 있다면 이를 사용해 효과적으로 알고리즘을 선택할 수 있을 것이다.)

# O(logN)

> `데이터가 2배` 증가할때마다 `알고리즘은 한 단계`씩 늘어난다.
> 

이진 검색은

- O(1)이 아니다 : 데이터가 증가하면 단계 수도 증가한다
- O(N)도 아니다 : 단계수의 증가가 데이터의 증가량보다 훨씬 작다.

즉, 이진 검색의 빅 오는 O(1)과 O(N) 사이 어딘가 - logN - 에 존재한다.

→ **‘원소가 하나만 남을 때까지 데이터를 계속해서 반으로 줄이는 만큼’ 의 단계**

![bigO3](https://user-images.githubusercontent.com/97890886/166230117-8352c637-0a81-4967-adcd-09f7f8543972.png)

# N을 찾는 방법과 빅 오 표기법의 적용

지금까지 살펴본 예제는 데이터를 배열로 한정하였기 때문의 N의 의미 역시 배열의 데이터 원소로 한정되었다.

그럼 다음과 같은 코드를 빅 오 표기법으로 나타내면 어떨까?

```jsx
function prime(num) {
    for (i=2; i<num; i++) {
        if (num % i === 0) return `소수가 아닙니다`;
    }
    return `소수입니다`;
}

console.log(prime(2));
console.log(prime(16));
```

소수를 가려내는 간단한 코드이다.

> 위 코드에서의 N은 `매개변수(num)에 전달되는 수`이며, 이 때의 `단계 수`가 빅 오 값이다.
> 

num에 2가 오면 반복문은 2번 수행된다. 3이 오면 3번 수행된다. 즉, 위 코드는 O(N)이다.

빅 오 표기법의 본질-데이터의 양에 따른 단계 수의 변화-을 깨닫는 순간, 어떤 코드든 빅 오로 해석이 가능하다. 일단 ‘데이터의 양(N)’, 즉 데이터란 무엇인지를 먼저 파악한다. 그리고 이 증진량이 실제 코드가 실행되는 단계 수의 변화에 얼마나 영향을 미치는지를 분석한다.

지금까지 알아본 것 같이, `빅 오 표기법`은 알고리즘의 성능을 비교하는 일관된 시스템이며 이를 사용해 프로그램 시나리오를 분석하여 다양한 자료구조와 알고리즘 중 더 나은(사용자의 코드를 더 빠르게 하고 큰 부하도 처리할 수 있다) 방법을 선택할 수 있다.
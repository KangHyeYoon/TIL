# 포인터와 차원의 관계

포인터의 차원은 자신이 가리키는 대상만큼 증가합니다. 차원이 늘어날수록, 사슬처럼 모든 대상이 이어져 있는 것이나 다름없죠. 예를 들어 ‘나의 친구의 친구’ 가 있을 때, ‘나’는 ‘친구’도 가리키고 ‘친구의 친구’도 가리킨다는 것입니다.

# 다차원 포인터

## 선언하기

```c
char *p1;
char **p2;
char ***p3;
```

차원만큼 *를 붙여줍니다.

# 2차원 포인터

다차원 포인터는 말 그대로 2차원도, 3차원도, 4차원도 될 수 있습니다. 무궁무진합니다. 그러나 2차원 포인터의 원리만 이해한다면, 이후 차원은 똑같은 원리의 반복입니다. 또한 2차원 배열을 다루는 데에 있어서 2차원 포인터가 아주 효과적이기 때문에, 2차원 포인터에 대한 탐구가 필요합니다.

## 2차원 포인터 선언하기

```c
short **pp;
```

## 2차원 포인터의 구성

- 구조 - 기본

```c
short **pp, *p, data = 3;
p = &data;    // 포인터 변수 p(1차원)에 data(0차원)의 주소 저장
pp = &p;    // 포인터 변수 pp(2차원)에 p(1차원)의 주소 저장
**p = 5;    // data의 주소에 찾아가 5라는 값 저장
```

![9 2차원포인터의구성_정석](https://user-images.githubusercontent.com/97890886/161970598-b1d11185-d94b-4eda-a877-d9fbf661ff9f.png)

차원을 하나씩 건너뛰면서 각 포인터가 가리키는 대상이 이전 차원의 주소인 경우가 이상적이다. 이동하면서 차원이 하나씩 줄어드는 계단같은 구조나 다름없다. 또한 밑에서 살펴볼 error 예시처럼 casing을 해줄 필요도 없다.

>구조 - error!

```c
short **pp;
int data = 3;
pp = (short *) &data;    // casting 형변환
```

**2차원 포인터 pp의 주소는 1차원 포인터의 주소를 가지고 있어야** *pp로 1차원 포인터에 접근이 가능해지며 **pp로 0차원(대상)에 접근할 수 있다. 만약 2차원 포인터가 대상의 주소값을 직접적으로 갖게 되면 오류가 발생한다.

>구조 - 1>0>0

2차원>1차원>0차원(대상)이 아닌, 1차원>1차원>0차원(대상)인 경우.

```c
int *q, *p, data=3;
p=&data;
q=(int *)&p;    // casting
```

![10 2차원포인터의 구성_1](https://user-images.githubusercontent.com/97890886/161970651-9be26bb1-4e46-48e0-b5e4-1201609f8c54.png)


error는 아니지만, 1차원 포인터에서 다음 1차원 포인터로 이동하는 것이 불가능하므로 2차원 포인터 구조에 비해서 실용성이 떨어진다.  또한 1차원 포인터가 다른 1차원 포인터의 주소값을 가지도록 선언하는 시점부터 이미 차원이 하나 증가하기 때문에 차원을 맞추기 위한 catsting이 불가피하므로 불편하다.

>구조 - 2>0>0

2차원>1차원>0차원(대상)이 아닌, 2차원>1차원>0차원>0차원인 경우.

```c
short **pp, data = 3;
int ptr = (int) &data;    // 일반변수 ptr에 대상 data의 주소 저장
pp = (short **) &ptr;    // casting
**pp = 5;
```

![11 2차원포인터의구성_2](https://user-images.githubusercontent.com/97890886/161970703-7e4f0147-23f8-4428-a585-c71c61f54796.png)

2차원 포인터가 가리키는 대상이 1차원이 아니라 0차원인 경우는 원래는 불가능하지만, 그 0차원이 최종 대상의 주소 값만 가지고 있다면 어찌저찌 가능은 하다. 즉 2차원 포인터는 1차원 포인터가 아니더라도, 변수 형태로 저장된 4바이트 주소 값을 사용해 최종 대상을 사용할 수 있는 것이다. 그러나 이런 형태에서는 당연하게도 하위 차원에서의 이동은 불가능하다. 또한 cating이 상당히 귀찮다.

# 2차원 포인터와 메모리 동적 할당

2차원 포인터가 가리키는 대상의 메모리를 동적 할당 해보자.

```c
short **pp, data = 3;
pp = (short **) malloc(4);    // 2차원이 가리키는 대상의 주소를 동적할당
*pp = &data;
**pp = 5;
```

2차원 포인터를 구성할 때,  포인터 두 개를 각각 선언해줘야 했을 때보다 훨씬 보기가 좋다.

동적할당된 2번째 메모리 공간은 나머지 두 공간과 달리 혼자만 Heap이기 때문에 메모리 번짓수가 차이가 좀 있다. 이 4바이트 Heap 메모리는 엄밀히 말하면 포인터 변수는 아니지만, 포인터의 역할을 하기 때문에 (**pp를 사용했을 때 이 메모리를 거쳐, 주소를 읽어서 대상을 찾아가므로) short * 로 선언된 포인터와 같은 느낌을 준다.

```c
pp = (short **)maloc(sizeof(short *))    // short *는 포인터이므로 크기는 4바이트
```

결론적으로 이 구조는 short형 포인터를 동적으로 메모리 할당하여 그 주소값을 2차원 포인터 pp에 저장한 형태로, 1차원 포인터 한 개를 동적 할당한 것이나 다름없다.

> 주의! 동적 할당한 메모리를 해제하는 순서

```c
short **pp;
pp = (short **)malloc(sizeof(short *));
*pp = (short *)malloc(sizeof(short));

**pp=10;
printf("**pp=%d\n", **pp);
free(*pp);
free(pp);
```

두 번째 메모리인 pp는 세 번째 메모리 *pp의 주소 값을 가지고 있으므로, pp를 먼저 해제하면 *pp의 값을 잃어버리므로 메모리 손실 위험이 있다 (마치 마트료시카 구조)

>2차원이 가리키는 대상을 동적으로 할당했을 때의 장점

동적 메모리 할당은 가리키는 대상의 메모리를 나눠서 여러개인 것처럼 사용할 수 있다.

```c
short **pp = (short **)malloc(3 * sizeof(short *));
// 총 12바이트를 3*4 구조로, 4바이트 단위로 3개씩 나눠서 사용한다.
```

각각의 메모리는 주소 연산 방법으로 *(pp+0), *(pp+1), *(pp+2)로 접근한다.

2차원 포인터 동적 할당 구조는 2차원 배열의 한계점(2차원 배열은 객체지향과는 거리가 멀다)을 해결해줄 수 있다. 이는 자세하게 이후의 내용에서 배워보겠다.

# 2차원 포인터와 매개변수

>error case 1

2차원 포인터를 사용하지 않았을 때

```c
#include <stdio.h>
#include <malloc.h>

void GetMydata(int *q)
{
    q = (int *)malloc(8);
}

void main()
{
    int *p;
    GetMydata(p);
    *p=5;
    free(p);
}
```

main 함수의 포인터 변수 p가 매개변수 int *q에 복사될 때 원하지 않는 주소 값(초기화되지 않은 변수이기 때문에 남아있는 trash값)이 전달되어, 메모리를 할당하더라도 그 메모리의 주소값은 q에 저장되었을 뿐 p는 변화없이 여전히 trash값을 저장하고 있다.

>error case 2

error case 1의 보완 : p에 직접적으로 q에 저장된 메모리 주소 값을 대입해보았을 때

```c
#include <stdio.h>
#include <malloc.h>

void GetMydata(int *q)
{
    q = (int *)malloc(8);
    *p = q;    // 코드 추가로 보완
}

void main()
{
    int *p;
    GetMydata(p);
    *p=5;
    free(p);
}
```

이렇게 하면 될 거라고 생가하겠지만, 안 된다. 왜냐? 지역변수는 다른 함수에선 사용할 수 없기 때문이다.

>매개변수에 2차원 포인터를 사용해보자

과거에 배웠던 포인터의 내용을 상기시켜보자.  


💡 *A함수에서 B함수의 지역변수 p의 값을 변경하고 싶다면, A함수에서 매개변수 q로 p의 '이름(변수명)'이 아닌 '주소(포인터)'를 전달받아 처리해야 한다.*


이때 우리의 예시에서는 p가 일반 변수가 아닌 (1차원)포인터 변수이므로 p의 주소값을 전달받는 매개변수 q는 2차원 포인터여야 하는 것이다. 차원이 맞아야 한다.

```c
#include <stdio.h>
#include <malloc.h>

void GetMydata(int **q)     // 매개변수 2차원 포인터 q : p의 주소 값 저장함
{
    *q = (int *)malloc(8);      // q가 가리키는 대상(==p)에 동적 할당된 8바이트의 메모리 저장
}

void main()
{
    int *p;
    GetMydata(&p);      // q에게 1차원 포인터 p의 주소값을 매개변수로 전달
    *p=5;       // 할당된 메모리의 첫 4바이트에 값 5 대입
    free(p);
}
```

이렇게 되면, 내부적으로 int **q = &p; 가 되면서 위에서 배웠던 2차원 포인터의 정석적인 구조가 나온다.

# 2차원 포인터와 2차원 배열

여러 개의 1차원 포인터를 할당하는 경우

>2차원 배열[정적]

```c
short *p[100];    // short * 형식의 1차원 포인터 100개 선언
```

정적 할당의 한계점: 선언할 때 메모리 크기가 고정된다 >

1. 이후 포인터가 100개가 아닌 200개, 300개가 필요하게 되면 소스코드 재작성 및 재컴파일을 해야 하므로 불편
2. 포인터를 100개나 선언했는데 5개만 사용된다면 메모리 낭비됨

>2차원 포인터[동적]

```c
short **pp;
pp=(short **)malloc(sizeof(short *));
```

2차원 포인터가 첫 번째로 가리키는 대상은 1차원 포인터가 가장 적합하지만, 제대로 된 주소값만 가지고 있다면 4바이트 크기의 메모리라도 상관 없으므로 malloc으로 동적 할당+분할하였다.

```c
int n;
short **pp;
printf("할당받을 메모리 최대값 입력: \n");
scanf("%d", &n);
pp=(short **)malloc(sizeof(short *)*n);
```

다음과 같이 사용자에게 최대 메모리 수치를 입력받아 동적 할당하면, 위에서 살펴보았던 2차원 배열의 한계를 커버할 수 있다.
# 배열과 포인터

> 변수 표현 방식의 확장
> 
변수를 사용할 때 또한 변수를 선언할 때 변수의 역할이나 특성이 결정되므로 표현 방식의 선택은 아주 중요하다.

# 배열 표기법과 포인터 표기법의 관계

## 변수의 시작 기준

- **포인터**: 포인터 변수가 가리키는 메모리의 시작 주소
- **배열**: 해당 배열이 사용하는 메모리 그룹의 시작 주소

표기만 다를 뿐 문법 구조는 비슷하다. 두 분법의 표기를 바꿔서 사용해보자.

```c
// 배열의 경우
char data[5];

data[1]=5;
*(data+1)=5;
// 둘이 같습니다
```

```c
// 포인터의 경우
char data;
char *p=&data;

*p=3;
data[0]=3;
// 둘이 같습니다
```

![6 배열과포인터_표기비스](https://user-images.githubusercontent.com/97890886/161420220-2fbefc23-1ea1-4edc-89af-6ecc4970383f.png)

# 배열의 한계점을 포인터로 해결하기

4바이트 크기의 요소 0x12345678의 값을 1바이트 단위만 변경하여 0x12345622로 만들고 싶다면?

## 배열 표기법의 한계

```c
int data[2] = {0x12345678, 0x12345678};
data[1] = 0x22;
// 배열로는 바이트 단위의 대입은 불가능
// 0x00000022 가 된다
```

배열은 요소의 수정만 가능할 뿐, 요소를 구성하는 각 바이트의 값을 변경하지는 못한다.

## 포인터 표기법으로 해결하기

```c
int data[2] = {0x12345678, 0x12345678};
*(data+1) = 0x22;
// 앞의 코드를 포인터 표기법으로 작성해 본 것
```

포인터 표기법은 `casting`이 가능하다. char*형으로 casting해준다면 `1바이트 단위`로도 충분히 작업이 가능하다.

```c
*(char)(data+1) = 0x22;
// int(4바이트)값을 char(1바이트)단위로 변경
```

# 포인터의 복잡성을 배열로 해결하기

```c
int tips=0x12345678, sum;
char *p = (char *)&tips;    // int형 변수 tips에 1바이트씩 접근하기 위해 char* 포인터 선언 + 형변환
sum = *(p+0)+*(p+1)+*(p+2)+*(p+3);      //각 바이트를 합산함
```

*(p+1)과 같은 포인터 문법은 컴퓨터가 두 번의 연산(포인터 연산, 산수 연산)을 거쳐야 하므로 복잡하다. 이를 배열로 간단하게 나타내보자.

```c
sum = p[0] + p[1] + p[2] + p[3];
// 이처럼 포인터가 여러번 사용된 코드 -> 배열 코드로 바꾸면 단순해지긴 한다.
```

# 배열을 품는 포인터

## 배열을 ‘가리키는’ 포인터

```c
char data[4];

char *p = &data[0]; // 배열의 시작주소=배열의 첫 번째 요소의 시작주소
char *p = &*(data+0); // 배열을 포인터 문법으로 표기
char *p = data; // &와 * 연산자 상쇄-> 생략

char *p = &data;
// -char *형식이나 char []형식이 아닌
// char (*)[5]의 형식을 사용하므로
// 위 코드들과는 다른 의미를 갖음에 주의한다
```

포인터는 일반 변수뿐만 아니라 배열의 변수도 가질 수 있다. 선언 문법은 위와 같이 다양하게 생략 및 표시가 가능하다.

> 배열은 포인터가 될 수 없다

```c
char data[5];
data = data +1;
// error !
```

그러나 이렇게 배열이 포인터와 비슷하게 작동한다고 해서 포인터가 될 수 있는건 아니다.

- *포인터 : 다른 변수의 주소를 저장 가능*
- *배열 :컴파일러가 제공하는 메모리 그룹화 기술*

즉 내부를 보면 실제로는 '상수화된 주소' 이며 변수가 자신의 주소를 변경 못하듯이, 변수를 모아놓은 배열 역시 변경 불가능.

## 배열을 ‘사용하는’ 포인터

배열의 특정 요소들이 지속적으로, 반복적으로 많이 사용되는 경우 보다 효율적인 코드를 위해 요소들의 주소를 포인터 변수에 저장해 놓기도 한다.

```c
char data[5] = {1,2,3,4,5};
int i, sum=0, select=2;
for (i=0; i<5; i++) sum=sum+data[select];
```

이 코드는 단순해 보이지만 사실은 내부적으로는

```c
for (i=0; i<5; i++) sum=sum+*(data+select)
```

배열의 색인index 작업 또한 연산이다.

```c
char data[5]={1,2,3,4,5};
int i, sum=0, select=2;
char *p = data+select;
for (i=0; i<5; i++) sum = sum+*p;
```

data[select] 요소의 주소를 포인터 p에 저장하여 *p로 data[select]의 연산을 대신하였다.

>예제 코드: 포인터를 사용하여 배열의 각 요소에 저장된 값 합산

```c
#include <stdio.h>

void main()
{
    char data[] = {1,2,3,4,5};
    int result=0, i;
    char *p = data;

    for (i=0; i<5; i++) {
        result=result+*p;
        p++;
        // result = result+ *p++; 로 줄여서 쓸 수도 있다
        // ++ 연산자가 후위 연산자이기 때문에 *p 연산을 수행 한 후 p++연산을 수행하게 되기 때문이다
    }
    printf("모든 배열의 합은 %d\n", result);
}
```

# 배열과 포인터의 합체

`배열` 기준: char *p[5];

`포인터` 기준: char (*p)[5] 

```c
char *(p[5]); // p[5]라는 배열에 대한 각각의 포인터 배열 생성
char (*p)[5]; // 가리키는 대상(배열)의 크기가 5바이트인 포인터 p
```

## 배열 기준: 포인터를 배열 형태로 그룹화하기

포인터도 변수의 일종임을 이용하여, 포인터를 배열 형식으로 그룹화하여 선언 및 사용한다.


![7 포인터를_배열기준으로_사용](https://user-images.githubusercontent.com/97890886/161420288-d1bbe59d-ac55-42a8-a9c5-e3d6fab05567.png)


- 배열형 포인터 선언

```c
char *p1, *p2, *p3;
// 나열식 표기법은 한계가 있다.
char *p[5]
// char형 포인터 5개가 있는 배열
// 크기는 20바이트(포인터 변수의 기본 크기*5)
```

- 배열형 포인터 사용하기

```c
p[0], p[1], p[2]    // 각 포인터를 사용하고 싶을 때
*p[0], *p[1], *p[2]     // 각 포인터가 가리키는 대상의 값을 사용하고 싶을 때
```

- 사용 예시

```c
char data1, data2, data3;
char *p[3] = {&data1, &data2, &data3};    // 포인터를 선언하는 동시에 각 포인터가 사용할 주소까지 초기화
for (i=0; i<3; i++) *p[i] = 0;          // 각 변수의 값에 모두 0이 저장됨
```

## 포인터 기준: 가리키는 대상이 배열인 포인터

- 배열을 가리키는 포인터 선언

```c
char (*p)[5];
```

- 포인터로 배열의 요소 사용

```c
(*p)[2] = 7;
// 포인터 p가 가리키는 배열의 3번째 요소에 7 대입
```

`일반적인  포인터`는 *p 명령어로 자신이 가리키는 대상에 찾아가서 값을 변경하지만, `배열을 가리키는 포인터`는 그 배열 내에서 한 번 더 -인덱스를 사용하여-요소를 선택해야 한다.

- 배열 내 포인터 주소 연산

```c
p++;
// 포인터 주소 연산
// 포인터가 가리키는 대상의 크기만큼 연산되므로
// char만큼 x 5바이트(배열의 크기)만큼 커진다
```

### 2차원 배열에서의 응용

배열을 가리키는 포인터는 2차원 배열과 구조가 비슷하다.


![8 배열을_포인터기준으로](https://user-images.githubusercontent.com/97890886/161420302-90df9a66-70cc-4b43-b9be-ba618de95795.png)
# C언어를 유연하게 만들어 주는 간접 매개체

컴퓨터 운영체제와 운영체제의 메모리 관리 방식과 가장 밀접한 문법, 포인터. 이처럼 하드웨어의 원리와 가까운 문법이지만 아이러니하게도 C언어의 딱딱함을 보다 부드럽게 해 줍니다.

## 변수

포인터를 이해하기에 앞서, C언어에서의 변수의 의미를 다시 짚고 넘어가도록 하죠.

<aside>
✔️ 변수: 데이터가 저장되는 공간인 메모리의 주소의 별명

</aside>

변수의 이름을 직접적으로 사용하지 않아도 변수의 주소만 알고 있다면 변수 값을 읽거나 바꿀 수 있을 것입니다. 이 ‘주소’는 포인터의 개념의 상당부분을 차지합니다. 잘 이해해 놓아야 합니다.

## 메모리 주소 지정 방식

운영체제는 메모리 주소를 1바이트 단위로 관리하며, 각 메모리에는 주소가 매겨져 있습니다. 메모리를 사용하려면 반드시 주소를 지정해야 합니다.

프로그래머는 메모리를 사용할 때 크기를 알려줄 필요가 있습니다.

### 1. 직접 주소 지정 방식

```wasm
mov word ptr[0000066h], 0412h
```

```c
short birthday;
birthday = 0x0412;
```

프로그래머가 사용할 메모리 주소를 직접 명시해 대입하는 방법입니다.

<aside>
✔️ 0x0412값을 0x00000066번지에 2바이트 크기로 저장하겠다

</aside>

위 코드는 이런 뜻입니다.

직접 주소 방식은 변수 문법과 상당히 유사한데, 어떤 값을 특정 주소 공간에 대입한다는 개념이기 때문입니다. 실제로 C언어에서 변수는 이런 원리로 작동됩니다.

### 1-1. 직접 주소 지정 방식의 한계

C언어의 직접 주소 지정 방식은 (지역)변수 개념을 사용하므로, 문법 구조상 서로 다른 함수에 존재하는 변수를 참조할 수 없습니다.

함수의 매개변수와 변환값을 사용하면 참조가 가능하지만, 값을 저장하고 싶은 주소를 바꿀 때에 명령을 일일이 수정해줘야 하고 이는 상당히 귀찮고 어려운 작업이며 객체지향적으로도 어긋납니다.

```c
#include <stdio.h>

void Test(short data)
{
    short soft = 0;
    soft = data;
    num=3;     // error: 다른 함수의 지역변수는 참조할 수 없다
}

void main()
{
    short num = 10;
    Test(num);
}
```

### 2. 간접 주소 지정 방식

![5_간접주소지정방식](https://user-images.githubusercontent.com/97890886/160608273-f92257b3-10fa-4239-aba0-4c0cd32ce74b.png)
직접 주소 지정 방식이 변수라면, 간접 주소 지정 방식은 포인터이다. 포인터는 사용할 메모리의 ‘주소’를 저장하고 있다. 값을 저장할 실제 메모리 주소를 명시하지 않고, 그 주소를 가리키는 매개체를 사용하는 것이다.

간접 주소 방식은 직접 주소 방식의 한계를 해결한다.

- 서로 다른 함수에 선언된 변수를 사용할 수 있다.
- 다른 함수의 값을 단순히 읽는 것 뿐만 아니라 변경이 가능하다.

# 포인터

## 포인터 선언하기

```c
short *ptr;
```

- short : 자료형
- * : 포인터라는 뜻의 기호
- ptr : 변수명

Q1. ptr의 크기는 2바이트인가?

A1. 아니다. 일반 변수는 자료형이 곧 변수의 크기였지만, 포인터 변수는 자료형을 선언하지 않아도 자동으로 정해진다. (값의 크기와 같거나 32비트 체제의 특성상 4바이트)

Q2. 그렇다면 자료형 short는 무엇을 의미하는가?

A2. 저장된 주소를 찾아가서 저장될 “값”의 자료형이다.

```c
short birthday;  #birthday라는 short형 변수 선언
short *ptr;  #ptr라는 포인터 선언
ptr = &birthday;  #ptr에 birthday의 주소 대입
*ptr = 1042;  #ptr에 저장된 주소에 찾아가서 1042 값 대입
```

프로그램은 실행될 때마다 메모리 주소가 리셋되므로, 포인터가 가리키는 대상의 주소, 그러니까 포인터에 저장되는 주소를 직접 입력해서 저장하는 것은 위험하다. 주소를 직접 명시하는 것 보다 다른 변수의 주소를 받아와서 사용하는 것이 안전하다.

```c
short *ptr = &birthday;
```

포인터 선언은 이렇게 보다 간결하게 가능합니다. 선언+주소 대입을 한 번에.

## 포인터 사용 시 주의점

### ptr과 *ptr의 구분

- ptr= : 포인터가 가리키는 대상의 주소(의 값)를 지정합니다.
- *ptr = 포인터가 가리키는 대상의 값을 지정합니다.

### *기호의 구분

```c
short *ptr = &birthday;
```

선언 키워드 : 포인터 변수를 선언하기 위해 사용하는 키워드

```c
*ptr = 1042;
```

번지 지정 연산자 : ptr이라는 포인터가 가리키는 대상에 가서 1042라는 값을 대입

## 직접 주소 방식의 한계를 해결

직접 주소 방식은 C언어에서는 변수로 표현되는데, 이는 곧 지역변수이므로 서로 다른 함수에서는 참조가 불가능하다는 불편함이 있었다.

간접 주소 방식(포인터)를 사용하면 다른 함수에 선언된 변수를 바로 사용할 수 있다.

```c
#include <stdio.h>

void Test(short *ptr)
{
    short soft = 0;
    soft = *ptr;
    *ptr=3;     // 2단계 : ptr이라는 포인터에 대입된 num의 주소를 찾아가서 3을 대입합니다
                //        변수의 값을 받아오는 것 뿐만 아니라 변수의 값을 변경하는 것도 가능한 것입니다
}

void main()
{
    short num = 10;
    Test(&num);     // 1단계 : 매개변수로 num의 주소가 전달되면서 ptr이라는 포인터에 num의 주소가 복사됨
}
```

또한 포인터는 직접 주소 방식과는 달리, 메모리에 저장된 값을 변경할 수가 있다. 다음 예제를 통해 알아보자. 

### 예제: 두 변수의 값 서로 바꾸기

### fail code 1 - 변수 사용 시 주의

```c
#include <stdio.h>

void main()
{
    int start = 96, end = 4;
    if (start > end) {
        end = start;
        start = end;
    }
}
```

변수는 한 번에 한 개의 값만 저장 가능하므로 end에 start를 대입한 순간 end가 96이 되어버리면서 본래의 값인 4는 사라지고 만다.

### fail code 2 - 간접 주소 지정 방식(변수)

```c
#include <stdio.h>

void Swap(int x, int y)
{
    int temp=x;
    x=y;
    y=temp;
}

void main()
{
    int num1 = 96, num2=4;
    if (num1>num2) {
        Swap(num1,num2);
    }

    printf("num1의 값은 %d이고 num2의 값은 %d이다\n", num1, num2);
}
```

간접 주소 방식도 함수의 매개변수와 반환을 사용하여 다른 함수의 지역변수를 참조할 수 있지만, 변수의 값을 변경하지는 못한다.

### success code - 직접 주소 지정 방식(포인터)

```c
#include <stdio.h>

void Swap(int *p1, int *p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p1 = temp;
}

void main()
{
    int num1=96, num2=4;
    if (num1>num2) {
        Swap(&num1, &num2);
    }
    printf("num1은 %d이고 num2는 %d이다\n", num1, num2);
}
```

매개변수 대신 포인터를 사용하면, 직접적인 값 대신 메모리의 주소를 받는다. **즉 직접적으로 값을 바꾸는 것이 아닌, 값을 가리키는 주소라는 중간매체를 바꾸는 것이다.** 이 과정은 서로 다른 함수에서도 아주 유연하게 적용이 된다. 결론적으로 포인터가 가리키는 대상 메모리의 주소를 통해 메모리의 값까지 접근하여 값을 변경하는 것이 가능하다.

## 포인터의 주소 연산

자신이 가리키는 대상의 크기만큼 계산된다.

### 자신이 사용할 메모리의 범위를 기억하는 방법

<aside>
✔️ 시작 주소 + 끝 주소를 기억한다.

</aside>

<aside>
✔️ 시작 주소 + 사용할 크기를 기억한다.

</aside>

두 방법 전부, 두 개를 기억해야 하므로 각각 4바이트여서 총 8바이트 일 것 같지만, C언어는 메모리를 사용할 때 항상 메모리의 크기를 먼저 결정하도록 되어있다(자료형). 즉 두 번째 방법에서는 시작 주소만 기억하면 된다. →  연산 시 시작 주소가 사용된다.

```c
short data = 0;
short *p = &data;  #data의 시작 주소 저장
*p = 5;  #시작 주소(&data)부터 2바이트(short)크기의 메모리에 5라는 값 저장
```

### 포인터 주소 연산

```c
short data = 0;
short *p = &data;
p = p+1;
```

포인터(에 저장된)가 가리키는 대상의 주소 값을 1만큼 증가시키는 코드이다.

- 포인터 주소연산에서 +1의 의미는 일반 산수가 아닌, 그 다음 데이터의 주소를 의미한다. (ex. 10번째 주소 > +1 > 11번째 주소)
- 즉, 포인터가 가리키는 대상의 데이터의 크기(여기서는 short)만큼 증가한다.

위 예시의 p+1값은 2바이트 후의 주소이므로 +2로 계산해야 하는 것이다.

### 포인터 주소 연산의 이점

포인터 주소 연산을 이용하면, 우리가 사용하려는 메모리의 시작 주소를 가리키는 포인터만 알고 있다면 주소 연산을 통해 다음 메모리를 자유롭게 사용할 수 있다.

## 포인터의 크기 & 대상의 크기

일반적으로 포인터의 크기는 포인터가 가리키는 값의 크기와 같게 지정하는 것이 일반적이다.

```c
int data = 0;
int *p = &data;
```

### if (포인터가 가리킬 수 있는 크기 ≠ 실제 대상의 크기)라면?

casting(형 변환)을 사용하여 포인터의 크기만큼 대상을 사용할 수 있습니다.

```c
int data = 0;
short *p = (short *)&data;
```

대상의 크기: 4바이트

포인터가 가리킬 수 있는 크기: 2바이트

*p를 사용하면 data 변수의 시작 주소에서 2바이트 크기만 사용이 가능합니다.

```c
#include <stdio.h>

void main()
{
    int data = 0x12345678, i;
    char *p = (char*) &data;  // &data는 int *형인데 이 주소를 저장할 포인터는 char *형.
                              // 자료형 불일치 > casting

    for (i=0; i<4; i++) {   // i++, 그러니까 i가 1씩 증가하는 연산은, 포인터 주소 연산에 따르면,
                            // 가리키는 대상의 자료형만큼 주소가 옮겨지는 건데,
                            // p가 char형이라서 1바이트 크기만 사용하는 것을 for문을 통해 반복하게 했다
                            // 즉, p가 가지고 있는 주소 값을 옮기면서 대상의 값을 출력하는 방식인 것이다
        printf("%X", *p);
    }
}
```

이를 for문에 적용하면 4바이트를 1바이트 단위로 출력하거나 하는 등의 코드가 가능합니다.

# const 키워드

불변의 상태를 지켜라!

## const의 필요성

만약 *p1 = *p2라는 코드를 p1 = p2라고 잘못 써 버렸을때의 문제점에 대해 생각해 보자.

```c
void Swap(int p1, int *p2)
{
    int temp = *p1;
    p1 = p2;  // p2에 저장되어 있던 주소가 p1에 복사되어 p1도 p2의 대상을 가리키게 된다.
    *p1 = temp;
}
```

*p1=*p2는 값 대입, p1=p2는 주소를 대입하는 문법이다. 즉 주소를 찾아가 값을 대입하는 것이 아닌, 주소 자체를 바꿔버린 것이며, 이 경우에는 결국 원하는 결과를 얻지 못하게 된다. Swap 함수가 원하는 것은 p1이 가리키는 대상의 주소와 p2이 가리키는 주소를 바꿔 main함수에서도 값이 다르게 출력되는 것인데, p1과 p2가 가리키는 대상이 같게 되므로 원하는 결과가 나오지 않는다.

이처럼 당연하게도 피호출자(Swap)에서 호출자(main)에게서 전달받은 주소를 변경하는  경우는 드물다. 그러나 컴파일러는 이를 오류로 인식하지 않으므로, 상당히 골치아픈 문제가 된다.

### const의 이점: 주소 변경 실수 방지

```c
void Swap(int *const p1, int *const p2)
{
    int temp = p1;
    p1 = p2;  // !! error !!
    p2 = temp;
}
```

const 키워드로 선언하면 값을 변경할 수 없다. “바꾸면 안 되는 값” “바뀌면 곤란해지는 값”에 주로 사용한다. 포인터 기호를 빼먹은 경우 골치아픈 에러가 되므로, 애초에 const를 사용해주면 간단하게 오류를 잡아낼 수 있게 된다.

## const 사용하기

### int *const p;

```c
int data=5, temp=0;
int *const p = &data;
*p = 3;     // p라는 포인터가 가리키고 있는 대상의 주소 data에 3을 대입
p = &temp;  // !! error !! p에 저장된 주소는 변경 불가능
```

- p라는 포인터 앞에 const 사용
- p가 가리키는 대상의 주소를 변경할 수 없다

### const int *p;

```c
int data=5, temp=0;
const int *p= &data;
*p = 3;     // !! error !! p가 가리키는 대상의 값 변경 불가능
p = &temp;  // p라는 포인터에 temp의 주소 저장
```

- int라는 ‘포인터 p가 대상의 주소에 접근 할 때 사용하는 자료형(크기)’ 앞에 const 사용
- p가 가리키는 대상의 값을 변경할 수 없다

### const int const* p;

```c
int data=5, temp=0;
const int *p= &data;
*p = 3;     // !! error !! p가 가리키는 대상의 값 변경 불가능
p = &temp;  // !! error !! p가 가리키는 대상의 주소 변경 불가능
```

- 둘다 포함. 둘다 안된다.

# void *형 포인터

- 포인터 변수가 가리키는 대상(의 주소에 대입될 값)의 크기가 (특정 자료형을 통해)정해지지 않은 포인터
- 크기가 미리 정해지지 않았으므로, 어떤 크기의 포인터(주소)든 저장할 수 있다. 그러나 주소를 사용할 때에는 포인터의 대상 메모리 크기를 명시해줘야 한다.
- 즉, 자신이 사용할 대상의 메모리 크기 지정을 조금 미루는 것이나 다름없다. 이는 소소한 이점이다.

### void *를 사용하지 않았을 때

```c
#include <stdio.h>

void MyFunc(int *p_int, char *p_char, short *p_short)
{
    if (p_char != NULL) p_char=1;
    else if (p_int !=NULL) p_int=1;
    else if (p_short != NULL) p_short=1;
}

void main()
{
    short data = 5;
    MyFunc(NULL, NULL, data);
}
```

어떤 형태의 주소 값이 전달될지 모르기 때문에 인자에 모든 자료형을 명시해놓아야 한다. 또 인자에 복사할 값을 전달할때도 NULL을 일일이 써 줘야해서 존나 불편함.

### void *를 사용했을 때

```c
#include <stdio.h>

int GetData(void *p_data, char type)
{
    int result;

    if (type==1) result = *(char *)p_data;
    else if (type==2) result = *(short *)p_data;
    else if (type==4) result = *(int *)p_data;

    return result;
}

void main ()
{
    int data = 0x12345678;
    printf("%X", GetData(&data, 4));
}
```
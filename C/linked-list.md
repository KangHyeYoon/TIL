# 링크드 리스트(linked-list)

컴파일 시점에 데이터를 저장할 메모리 크기가 결정되어 이를 런타임 도중에 변경할수 없는 `정적 할당`과 달리 런타임 도중에도 메모리 크기를 변경할 수 있는 `동적 할당`.

그러나 동적 할당도 사용자에게 **‘입력받은 개수만큼만’** 메모리를 사용할 수 있으므로 한계가 있습니다. 만약 사용자에게 메모리 크기의 입력을 요구하지 않고, 사용자가 입력하는 만큼 알아서 메모리가 동적 할당된다면 어떨까요? 이처럼 **리스트의 크기가 가변적인 자료구조**를 `링크드 리스트(liked list)`라고 합니다.

> 기존 방식

![13 링크드리스트_기존](https://user-images.githubusercontent.com/97890886/162206968-01c1100a-7cc2-48cf-8a49-637721dd6b3f.png)

> 연결 리스트 사용

![13 링크드리스트_이후](https://user-images.githubusercontent.com/97890886/162207010-4ac6bd2b-21ea-4a67-a0f1-695fb71675dc.png)


미리 입력받은 크기의 메모리 공간에 데이터를 채우는 방식이 아니라, 데이터를 입력받을 때마다 줄줄이 연결되어 무한확장되는 구조이다. 

이때 성공적으로 '연결' 되려면, `포인터`가 연결고리 역할을 해줘야 하는데, 포인터1이 숫자1만을 가리켜버리면 포인터2로 넘어가지 못해 끊겨버린다. 이를 해결하기 위해 숫자1과 다음대상을 가리킬 포인터2를 하나의 메모리로 묶어서 동적할당한다.


> ⭕ 링크드 리스트의 장점?


데이터의 개수를 예상할 수 없는 경우 저장 공간을 보다 효과적으로 사용할 수 있다.

# 구조체와 링크드 리스트

C언어에서 링크드 리스트라는 자료구조를 표현하는 가장 적합한 문법은 구조체이다. 한번 차근차근 구조체로 링크드 리스트를 구성해보자.

## step 1. 연결 리스트의 노드를 구조체로 선언하여 “노드의 기본적인 구조” 구성

![14 링크드리스트_시작](https://user-images.githubusercontent.com/97890886/162207177-d716f67b-2236-426b-862c-c2d8f42d26a7.png)

```c
typedef struct node
{
    int number;             // 숫자를 저장할 변수
    struct node *p_next;    // 다음 노드를 가리킬 포인터
} NODE;
```

첫 노드를 선언하여 노드의 구성을 작성한다. 노드 안에 데이터와 다음 노드를 가리킬 포인터가 들어 있는 구조이다.

## step 2. 연결 리스트에 노드를 추가하며 이어가기

### 2-1. 헤드 포인터 선언

![14 링크드리스트_진행](https://user-images.githubusercontent.com/97890886/162207283-5dd38641-36f6-4e13-b580-8aaca683ff0a.png)


```c

NODE *p_head = NULL;    // 첫 노드를 가리킬 헤드 포인터 선언
                        //NULL을 초깃값으로 대입하여 초기화
```

첫 노드의 값을 저장할 첫 포인터는 노드가 아니다: `헤드 포인터 (Head Pointer)`. 노드를 가리킬거니까 노드 자료형으로 선언해준다. NULL(해당하는 메모리 주소가 없음)을 초깃값으로 대입하여 초기화한다.

### 2-2. 데이터를 저장하기 위한 새 노드 추가

사용자가 12라는 값을 입력했다. 이 값을 링크드 리스트에 저장하려면 새로운 노드를 추가해야 한다.

```c
p_head=(NODE *)malloc(sizeof(NODE));    // 1. 새로운 노드를 위한 메모리를 malloc으로 동적 할당한다
/* 2. 이렇게 할당된 새 노드의 주소 값을 헤드 포인터가 가리키게 한다 */
p_head->number=12;                      // 2-1. 새로 할당된 노드의 number에는 12 값 대입
p_head->p_next=NULL;                    // 2-2.                   p_next에는 NULL 대입(아직 가리킬 다음 노드가 없음)
```

사용자가 15라는 값을 추가 입력했다. 이 값을 링크드 리스트에 저장하려면 또 새로운 노드를 추가해야 한다.

```c
p_head->p_next=(NODE *)malloc(sizeof(NODE));
p_head->p_next->number=12;
p_head->p_next->p_next=NULL;
```

이를 반복문으로 간단하게 해준다.

```c
NODE *p = p_head;   // 시작: p_head에 저장된 주소 값.
                    // 포인터 p는 현재 "시작" 을 가리키고 있는 것이다. (일종의 반복문을 위한 변수)
while(NULL != p->p_next) {      // p_next가 NULL일때까지 무한반복 한다는 뜻
                                // 다음 노드를 가리키는 포인터가 가리키는 것이 NULL이라면 연결리스트가 끝이 난 것이니까
    p = p->p_next;                // 그 전까지 다음 노드로 이동해준다
                                // p->p_next는 다음 노드로 이동한 것이고, 이걸 p에 대입해서 다음 노드로 이동한 값을 기본값으로 만들어 준 것
}
```

### 2-3. 조건을 체크하며 새 노드 추가

앞에서 살펴봤듯이,


> ✌️ 새 노드를 추가하는 것은 두 가지 상황이 있다.


1. 처음(p_head가 NULL): 연결 리스트에 노드가 하나도 없는 경우(p_head가 NULL인 경우)에 추가하는 경우

2. 이후(p_head가 NULL 이 아님): 걍 계속 반복적으로 무한동력 (여기는 while문을 써서 퉁치면 된다)


> 👉 이 두 가지 상황(조건)을 체크하여 새 노드 추가하는 코드를 함수 AddNumber로 만들어 보자.


2번은 헤드포인터 p_head와 첫 노드의 구조가 이미 완성되어 있는 상태에서 줄줄이 잇는 형태지만, 1번은 첫 노드의 주소가 NULL 대신 p_head에 들어가는 것이기 때문에 == p_head의 값이 변경되기 때문, 인자로 2차원 포인터를 받아서(포인터의 주소) 쓴다.

```c
void AddNumber(NODE **pp_head, int data)
{
    NODE *p;
    if (NULL != *pp_head) {     // 인자로 받은 헤드포인터가 NULL이 아닐 때, 즉 기존 연결 리스트에 노드가 이미 있을 때 (2번)
        p = *pp_head;           // pp_head의 값을 직접적으로 변경하지 않고 새 포인터 변수 p에 담아 코드를 실행할 것이다
                                // "처음(1번)"인 경우와 달리 "이후(2번)"은 이미 빌드되어있는 헤드포인터+첫 노드를 망가뜨리지 않아야 함

        while (NULL != p->p_next) p = p->p_next;        // 새 노드를 추가하기 위해, 마지막 노드를 찾아 헤메는 과정

        p->p_next = (NODE *)malloc(sizeof(NODE));       // 새(다음) 노드를 위한 메모리 동적 할당
        p = p->p_next;                                  // 새(다음) 노드의 주소값을 p에 저장
    }
    else {      // 인자로 받은 헤드포인터가 NULL일때, 즉 완전 처음일때 (1번)
                // 여기선 pp_head의 값을 직접적으로 만져서 메모리를 할당해줄 것이다

        **pp_head=(NODE *)malloc(sizeof(NODE));
        p = *pp_head;       // 새(다음) 노드의 주소값을 p에 저장
    }
    
    p->number=data;     // 새 노드의 number에 data 값 저장
    p->p_next=NULL;     // 다음 노드가 없음을 명시
    
}

// 이 함수를 사용해보자
// 기존 연결 리스트에 새 노드를 추가하고 값 15를 저장하고 싶다면?

NODE *p_head = NULL;
AddNumber(&p_head, 15);
```

### 2-4. 연결 리스트의 마지막 노드 기억하기

위에서 만들었던 AddNumber()의 치명적인 단점은, 조건문에서 NULL != p->p_next를 사용하였다는 것. 새 노드를 추가하기 위해서는 기존 노드에 끝에 가서 추가해야 하고, 그럼 일단 끝에 도달해야 하며, 이는 곧 끝(NULL)에 도달하기 전까지 계속해서 이동을 해야 한다는 것을 의미한다. 노드가 많아질수록 이러한 '마지막 노드를 찾기 위한 탐색'은 길어질 것이다 -> 속도 저하

>❕ 해결: 테일 포인터 (Tail Pointer) - 마치 헤드 포인터처럼 마지막 노드의 주소 값을 기억한다


테일 포인터로 끝을 기억하게 되면, 새 요소가 추가될 때 마지막 노드를 찾기 위해 일일이 탐색 X 테일 포인터가 가리키는 노드에 가서 바로 새 노드 추가 가능 O

```c
void AddNumber(NODE **pp_head, NODE **pp_tail, int data)
{
    if (NULL != *pp_head) {
        (*pp_tail)->p_next= (NODE *)malloc(sizeof(NODE));   // [끝] 다음에 -> 새 노드를 위한 메모리 동적 할당
        *pp_tail=(*pp_tail)->p_next;                        // 그렇게 할당된 새 노드가 새로운 [끝]이 된다
    }
    else {
        *pp_head=(NODE *)malloc(sizeof(NODE));
        *pp_tail=*pp_head;
    }
    (*pp_tail)->number=data;
    (*pp_tail)->p_next=NULL;
}
```

### 2-6. 링크드 리스트의 모든 노드 제거하기(메모리 해제)

동적으로 할당된 노드들은 free 함수를 호출하여 해제할 때까지 유지된다. 즉, 프로그램이 끝날 때 이 메모리들을 전부 해제하는 작업을 추가해야한다. 연결리스트를 구성하는 노드를 반복문을 통해 탐색하면서 하나씩 제거해 보자.

>fail code

```c
NODE *p = p_head;

while (NULL != p) {
    free(p);
    p = p->p_next;      // error !!
}
```

free(p); 를 하면 p가 가리키는 메모리가 해제되는데, 이 메모리에는 다음 노드의 주소 값을 기억하는 역할의 p_next가 있다. 즉 이미 해제된 메모리를 사용하려고 해서 오류가 발생한 것.

>clean code - 1

```c
NODE *p = p_head, *p_save_next;

while (NULL != p) {
    p_save_next = p->p_next;
    free(p);
    p = p_save_next;
}
p_head=p_tail=NULL;     // 시작부터 끝까지 전부 NULL (해제되었음, 제거되었음)임을 명시해줌
```

해제하기 전에, p->p_next에 저장된 주소값을 '다른 포인터 변수'에 옮겨 임시저장하는 방법이다.

>clean code - 2-1

```c
NODE *p;

while(NULL !=p_head) {      
    p = p_head->p_next;     // 현재 노드에서 다음 노드로 이동하는 것을 저장
    free(p_head);           // 현재 노드 제거
    p_head=p;               // 아까 저장해놨던 것을 사용하여 다음 노드로 이동
}
p_tail=p_head;
```

p의 역할을 p_head가 하고, p_save_next의 역할을 p가 하여 새로운 포인터 변수의 사용을 자제했다.

- clean code - 2-2

```c
/* 2-1의 다른 표현 */
while (NULL != p_head) {
   p=p_head;                // 현재 노드를 저장
   p_head=p_head->p_next;   // 현재 노드에서 다음 노드로 이동
   free(p);                 // 아까 저장해놨던 현재 노드(지금 시점에서는 이미 이전 노드가 된 상태)삭제
}
```

현재를 삭제하고 다음으로 이동하느냐, 다음으로 이동하고 (이제는 이전이 된) 현재를 삭제하느냐 의 차이이다.
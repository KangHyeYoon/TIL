# 버전 관리

버전 관리 시스템(VCS, Version Control System)은 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템이다

## 버전 관리의 역사

### 로컬 VCS

![image](https://user-images.githubusercontent.com/97890886/179756947-683a1dce-0604-416e-ac7a-5fd14b7ef5e5.png)

Patch Set(파일의 변경사항)을 관리하는 아주 간단한 로컬 버전 관리. Patch Set은 특별한 형식의 파일로 저장되며, 이를 적용해 모든 파일을 특정 시점으로 되돌릴 수 있다.

### CVCS(중앙집중식 VCS)

![image](https://user-images.githubusercontent.com/97890886/179756978-f2296852-a6c2-4d0e-b75b-818381ff2206.png)

파일을 관리하는 중앙서버가 별도로 있고 클라이언트가 중앙 서버에서 파일을 받아 사용(Checkout)한다.

- 장점 : 로컬 VCS과 비교하여, 모두가 “누가 무엇을 하고 있는지”를 파악 가능
- 단점 : 중앙 서버에 문제 발생 시 너무 치명적임

### DVCS(분산 버전 관리 시스템)

![image](https://user-images.githubusercontent.com/97890886/179757004-2bc7564d-6d75-4946-b75f-307ce9d06f09.png)

> `Clone`은 진정한 백업이다
> 

단순히 파일의 마지막 버전만을 Checkout하는 것이 아닌, 저장소 자체를 히스토리와 더불어 통째로 복제(Clone)한다. 서버에 문제가 생겨도 이 복제물로 다시 작업할 수 있다.

> `Remote 저장소`를 통해 협업할 수 있다
> 

원격 저장소들(많을 수도 있다)을 통해 동시에 다양한 그룹과 다양한 방법으로 협업할 수 있다. 계층 모델과 비슷한 CVCS의 한계를 극복한다.

# Git의 역사

Linux 개발 커뮤니티(특히 Linux 창시자인 Linus Torvalds)가 만들었다. 와 Linux나 Git이나 하나만 만들어도 대박인데 이걸…

간단히 말하자면, 상당히 오랜 시간동안 Patch와 단순 압축으로만 Linux 프젝을 관리하던 도중 드디어 상용 DVCS를 사용하기 시작했는데 이 회사가 이익을 과하게 추구하자 나머지 빡쳐서 Git을 만들어서 자체적으로 사용하고 있다…

- 빠른 속도, 단순한 구조
- 비선형적인 개발(브랜치), 완벽한 분산

# Git 기초

## 데이터를 바라보는 관점의 혁신

### 기존의 델타 기반 버전관리 시스템

![image](https://user-images.githubusercontent.com/97890886/179757301-73bfa4c7-d3fd-426d-8c1a-e016284babdd.png)

주로 파일을 중심으로 파일이 `변경된 내역`을 관리한다. 프로젝트 초반에 File A, File B, File C로 시작을 하였고 File A와 File C에만 기능을 추가하여 Version 2가 되었다면 이는 delta 1로 저장이 되고, 개발이 더 진행된 이후 Version2의 코드를 받아보려면 원본 파일에다가 File A와 File C에만 delta 1을 받아와야 하는 형식이다.

### 마치 “스냅샷의 스트림”

![image](https://user-images.githubusercontent.com/97890886/179757322-16c05503-1d2c-48c9-8038-f6c3f26903e0.png)



Git은 `프로젝트 전체`를 시간에 따라 스냅샷으로 찍은 것 처럼 순간순간을 찍어 연결한다. 커밋하거나 프로젝트의 상태를 저장할 때마다 파일이 존재하는 그 순간을 중요하게 여긴다. 파일이 달라지지 않았으면 Git은 성능을 위해서 파일을 새로 저장하지 않는다. 단지 이전 상태의 파일에 대한 링크만 저장한다. Git은 데이터를 **스냅샷의 스트림** 처럼 취급한다.

> Git은 데이터를 추가할 뿐
> 

Git으로 무얼 하든 Git 데이터베이스에 데이터가 ***추가***된다. 되돌리거나 데이터를 삭제할 방법이 없다. 일단 스냅샷을 커밋하고 나면 데이터를 잃어버리기 어렵다.

## 거의 모든 명령을 로컬에서 실행

전체 히스토리가 담긴 remote 저장소를 local에 그대로 clone한 덕분에, 대부분의 명령어가 네트워크의 속도에 영향을 받지 않고 오프라인 상태에서도 commit이 가능하다.

## 데이터의 세 가지 상태

### Modified

수정한 파일을 아직 로컬 데이터베이스에 commit하지 않음 (스테이지 X)

### Staged

현재 수정한 파일을 곧 commit할 것이라고 표시한 상태 (스테이지 O)

### Committed

데이터가 로컬 데이터베이스에 안전하게 저장됨

![image](https://user-images.githubusercontent.com/97890886/179757194-9e9c38ee-7c08-4a9a-9925-d48722805b4b.png)

- 워킹 트리 : 프로젝트의 특정 버전을 Checkout한 것
- Staging Area(Index) : 곧 커밋할 파일에 대한 정보를 저장(스테이지에 올리기)
- Git 디렉토리 : 저장소를 Clone할 때 지금 작업하는 디스크 내에 만들어지며, 프로젝트의 메타데이터와 객체 데이터베이스가 저장된다. 워킹 트리가 바로 이곳에서 파일을 가져와서(Checkout) 만들어진다.

1. 워킹 트리에서 파일을 수정한다.
2. Staging Area에 파일을 Stage 해서 커밋할 스냅샷을 만든다. 모든 파일을 추가할 수도 있고 선택하여 추가할 수도 있다.
3. Staging Area에 있는 파일들을 커밋해서 Git 디렉토리에 영구적인 스냅샷으로 저장한다.

# CLI

Git을 사용하는 방법으로는 GUI도 있지만 오직 `CLI`만이 **Git의 모든 기능을 지원**한다.

# Git 최초 설정

## git config

Git의 사용 환경 설정 내용을 확인/변경할 수 있는 도구.

### /etc/gitconfig 파일

- 시스템 전체 설정파일. (시스템의 모든 사용자 + 모든 저장소에 적용됨)
- 관리자 권한 필요

```jsx
git config --system
```

### ~/.gitconfig, ~/.config/git/config

- 현재 사용자 + 모든 저장소에게 적용되는 설정

```jsx
git config --global
```

### .git/config

특정 저장소(현재 작업중인 프로젝트 같은)에만 적용됨. 기본값이다.
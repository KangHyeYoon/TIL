프로그래밍 언어의 함수는 일련의 과정을 문statement로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

![function](https://user-images.githubusercontent.com/97890886/162613649-7091c6fe-3ce1-4a0f-9739-13cc5db4bd4f.png)

> 함수의 필요성
> 
1. 유지보수의 편의성
2. 코드의 재사용
3. 코드의 신뢰성
4. 코드의 기독성

# 함수 리터럴

자바스크립트의 함수는 객체 타입의 값이다. 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리터럴로 생성할 수 있다. 이는 평가되어 값을 생성하고 변수에 할당될 수 있다. 함수와 객체의 차이점은 일반 객체는 호출할 수 없지만 `함수`는 `호출`할 수 있다는 것이다. 함수가 객체라는 사실은 자바스크립트의 중요한 특징이며, 다른 언어와의 차별점이기도 하다.

```jsx
var f = function add(x,y) {
    return x+y;
};
```

## 함수 이름

- 함수 몸체 내에서만 참조할 수 있는 식별자로, 식별자 네이밍 규칙을 준수하라
- 생략 가능하다. (무명 함수)

## 매개변수 목록

- 함수 내에서 변수와 동일하게 취급되므로, 식별자 네이밍 규칙을 준수하라
- 순서에 의미가 있다 (인수와 순서대로 짝짓기)

## 함수 몸체

- 함수의 진짜 내용. 함수 호출에 의해 실행된다

# 함수 정의하기

1. 함수 선언문
2. 함수 표현식 (리터럴)
3. Function 생성자 함수
4. 화살표 함수 (ES6)

```jsx
// 함수 정의하기

// 1. 함수 선언문
function sum(x,y) {
    return x+y;
}

// 2. 함수 표현식 (리터럴)
var sum = function sum(x,y) {
    return x+y;
};

// 3. Function 생성자 함수
var sum = new Function('x', 'y', 'return x+y');

// 4. 화살표 함수 (ES6)
var sum = (x,y) => x+y;
```

## 함수 선언문

```jsx
// 함수 선언문으로 함수 선언하기
function sum(x,y) {
    return x+y;
}

// 함수 참조하기
// .log와 비슷하나, 함수 객체의 프로퍼티까지 출력
// node.js 환경에서는 log와 같은 결과
console.dir(sum);   // sum(x,y)

// 함수명 생략 불가능
function (x,y) {
    return x+y;
}   // SyntaxError : 식별자가 필요합니다.
```

- 함수 리터럴과 비슷하나 차이점으로는 `이름을 생략할 수 없다`는 점이 있다.
- `표현식이 아닌 문(statement)`이기 때문에 콘솔에서 undefined가 출력된다. 표현식이 맞는 문이었다면 평가되어 함수 자체가 출력되어야 했다.

> 함수 리터럴과 표현식이 아닌 문
> 

자바스크립트 엔진은 함수 리터럴을 중의적으로 해석한다. 기명 함수 리터럴(이름이 있는 함수)은 함수 선언문으로 선언한 함수와 리터럴 표현식으로 선언한 함수 둘 중 하나로 유연하게 해석된다.

- 함수 선언문으로 선언한 함수 : 표현식이 아닌 문으로, 변수에 할당이 불가능하다.
- 리터럴 표현식으로 선언한 함수 : 표현식인 문으로, 변수에 할당이 가능하다.

마치 { } 기호가 언제는 코드 블록으로, 언제는 객체 리터럴로 해석되어 전자는 ; 기호가 필요 없고 후자는 ; 기호가 필요한 것과 비슷하다. 자바스크립트 엔진은 문맥에 따라 값으로 평가될 필요가 있으면 리터럴 표현식으로 선언한 함수로 평가하여 값으로 평가하고(변수에 할당 가능하게 하거나 피연산자로 사용하고), 그럴 필요가 없으면 함수 선언문으로 선언한 함수로 평가한다.

```jsx
// 함수 선언문으로 해석되는 경우
// 기명 함수 리터럴을 단독으로 사용했을 때
function foo() {
    console.log('foo');
}

foo();  // foo

// 함수 리터럴 표현식으로 해석되는 경우
// 함수 리터럴을 피연산자로 사용했을 때
(function goo() {
    console.log('goo');
});

goo();  // ReferenceError: goo is not defined
```

두 방식은 함수 객체를 생성한다는 점에서 동일하지만 호출에 차이가 있다. 위 예제에서 봤듯이, foo는 호출이 가능하지만 goo는 불가능하다.

아까 함수 리터럴에 대해 알아봤을 때, 함수 이름은 **함수 몸체 내에서만** 참조할 수 있는 식별자라고 했다. 즉 함수 외부에서는 함수 이름으로 함수를 참조할 수 없으며, 이를 가능하게 하려면 함수 이름과는 별도로 생성된, 함수 객체를 가리키는 식별자가 필요하다. goo를 참조할 수 없는 이유는 goo라는 함수를 가리키는 식별자가 없기 때문이다. 

> 그렇다면 foo는 무엇일까?
> 

foo로 함수 foo()를 호출하려면 이를 식별자로써 선언하고 할당해야 한다. 그런데 우리는 한 적이 없다. 그저 함수만 선언했을 뿐이다. foo는 무엇일까?

<aside>
❕ 자바스크립트 엔진이  암묵적으로 생성한 식별자

</aside>

자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

즉, 함수는 `함수 이름`으로 호출하는 것이 아니라, `함수 객체를 가리키는 식별자`로 호출한다. 즉, 함수를 호출한 것은 함수 이름 foo가 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자 foo인 것이다.

![function2](https://user-images.githubusercontent.com/97890886/162613660-dbc1fc33-4f9d-4cec-a210-fc1ea6282ae0.png)

결론적으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 할 수 있다. 당연하게도 이 둘이 동일한 원리로 동작하는 것은 아니다. 

- `함수 선언문`은 `표현식이 아닌 문`이기 때문에 값처럼 사용할 수 없지만 자바스크립트 엔진이 암묵적으로 함수 리터럴 표현식처럼 동작하게 한다.
- `함수 표현식`은 `표현식인 문`이기 때문에 값처럼 사용할 수 있다. 함수명 스킵이 가능하며, 함수 표현식으로 선언한 함수 객체를 임의의 식별자에 할당했을 때 식별자로만 호출이 가능하고 함수명으로는 호출이 불가능함에 주의하라.

## 함수 표현식

함수 리터럴로 생성한 함수 객체를 (값처럼 사용하여) 변수에 할당하는 선언 방식.

> 자바스크립트의 함수는 객체 중에서도 일급 객체이다.
> 

일급 객체란 값의 성질을 갖는 객체이다. 변수에 할당되거나, 프로퍼티 값이 되거나, 배열의 요소가 될 수 있음. 즉 함수는 값처럼 자유롭게 사용될 수 있다.

```jsx
// 함수 표현식으로 함수 선언하기
var sum = function add(x,y) {
    return x+y;
};

// 함수 호출 : 함수 객체를 가리키는 식별자
console.log(sum(2,5));  // 7

// 함수 호출 : 함수 이름
console.log(add(2,5));  // ReferenceError: add is not defined
```

# 함수 호이스팅 function hoisting

`함수 선언문`으로 선언된 함수는 함수 호이스팅의 특징을 가지고, `함수 표현식`으로 선언된 함수는 변수 호이스팅의 특징을 지닌다.

## 함수 선언문과 함수 호이스팅

함수 선언문으로 선언된 함수는 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 함수 객체가 미리 생성된다.

즉, 코드가 한 줄씩 순차적으로 실행되기 시작하는 런타임 시점에는 이미 함수 객체와, 함수 이름과 동일한 식별자까지 생성이 완료되어 할당까지 끝난 상태이다. 따라서 함수 선언문 이전에도 함수를 참조하거나 호출할 수 있다. 이것이 바로 `함수 호이스팅`이다.

## 함수 표현식과 변수 호이스팅

함수 호이스팅과 변수 호이스팅은 미묘한 차이가 있다.

함수 표현식으로 선언된 함수 또한 함수 선언문으로 선언된 함수와 마찬가지로 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자가 생성되지만, `변수 키워드(var)`로 선언되었으므로 (변수 호이스팅) 자동으로 undefined로 초기화된다. 함수 객체로 초기화되는 함수 호이스팅과는 다르다.

(함수를 가리키는)변수는 런타임 이전에 평가되지만, (함수 그 자체)변수의 값은 할당문이 실행되는 시점(=런타임)에 평가되므로, 함수 리터럴 또한 런타임에 평가되어 비로소 함수 객체가 된다.

```jsx
// 함수 참조
console.dir(foo);    // [Function: foo]
console.dir(goo);    // undefined

// 함수 호출
console.log(foo(2,3));    // 6
console.log(goo(2,3));    // TypeError: goo is not a function

// 함수 선언 : 함수 선언문
function foo(a,b) {
    return a*b;
}

// 함수 선언 : 함수 표현식
var goo = function (x,y) {
    return x*y;
};
```

> 함수 호이스팅 vs 변수 호이스팅
> 
- 함수 선언문 : 자바스크립트 엔진에 의해 먼저 실행되어 식별자 생성, `함수 객체`로 초기화
- 함수 표현식 : 자바스크립트 엔진에 의해 먼저 실행되어 식별자 생성, `undifined`로 초기화. 함수 객체로 평가되는 것은 **런타임 이후**.

함수 호이스팅은 언뜻 보면 유연해 보이지만 규칙을 무시하는 위험한 요소이다. 또 같은 의미를 가지면서 보다 안정적인 함수 표현식이 이미 존재하므로, 후자를 사용할 것을 권장하는 추세이다.


![function3](https://user-images.githubusercontent.com/97890886/162613665-e2ab8bb9-7fb8-42c7-83f3-f29446db5d05.png)

# Function 생성자 함수

매개변수 목록과 함수 몸체를 문자열로 전달하면서 new연산자와 함께 호출하여 함수 객체를 생성하여 반환한다. 그러나 이 방식은 일반적이지도, 바람직하지도 않으며 클로저closure를 생성하지 않는 등 앞의 두 방식과 다른 원리로 동작한다.

> 생성자 함수
> 

객체를 생성하는 함수. 객체를 생성하는 다양한 함수 中 하나이다.

```jsx
// 3. Function 생성자 함수
var sum = new Function('x', 'y', 'return x+y');
```

# 화살표 함수

ES6에서 도입되었다. 항상 익명 함수(이름 X)로 정의한다. 표현이 상당히 간략화되어 있는데, 실제로 표현뿐만 아니라 내부 동작 또한 간략화되어 있다.

- 생성자 함수로 사용 불가
- 기존 함수와 this 바인딩 방식이 다름
- prototype 프로퍼티가 없음
- arguments 객체를 생성하지 않음
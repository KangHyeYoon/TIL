프로그래밍 언어의 함수는 일련의 과정을 문statement로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

![function](https://user-images.githubusercontent.com/97890886/162613649-7091c6fe-3ce1-4a0f-9739-13cc5db4bd4f.png)

> 함수의 필요성
> 
1. 유지보수의 편의성
2. 코드의 재사용
3. 코드의 신뢰성
4. 코드의 기독성

# 함수 리터럴

자바스크립트의 함수는 객체 타입의 값이다. 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리터럴로 생성할 수 있다. 이는 평가되어 값을 생성하고 변수에 할당될 수 있다. 함수와 객체의 차이점은 일반 객체는 호출할 수 없지만 `함수`는 `호출`할 수 있다는 것이다. 함수가 객체라는 사실은 자바스크립트의 중요한 특징이며, 다른 언어와의 차별점이기도 하다.

```jsx
var f = function add(x,y) {
    return x+y;
};
```

## 함수 이름

- 함수 몸체 내에서만 참조할 수 있는 식별자로, 식별자 네이밍 규칙을 준수하라
- 생략 가능하다. (무명 함수)

## 매개변수 목록

- 함수 내에서 변수와 동일하게 취급되므로, 식별자 네이밍 규칙을 준수하라
- 순서에 의미가 있다 (인수와 순서대로 짝짓기)

## 함수 몸체

- 함수의 진짜 내용. 함수 호출에 의해 실행된다

# 함수 정의하기

1. 함수 선언문
2. 함수 표현식 (리터럴)
3. Function 생성자 함수
4. 화살표 함수 (ES6)

```jsx
// 함수 정의하기

// 1. 함수 선언문
function sum(x,y) {
    return x+y;
}

// 2. 함수 표현식 (리터럴)
var sum = function sum(x,y) {
    return x+y;
};

// 3. Function 생성자 함수
var sum = new Function('x', 'y', 'return x+y');

// 4. 화살표 함수 (ES6)
var sum = (x,y) => x+y;
```

## 함수 선언문

```jsx
// 함수 선언문으로 함수 선언하기
function sum(x,y) {
    return x+y;
}

// 함수 참조하기
// .log와 비슷하나, 함수 객체의 프로퍼티까지 출력
// node.js 환경에서는 log와 같은 결과
console.dir(sum);   // sum(x,y)

// 함수명 생략 불가능
function (x,y) {
    return x+y;
}   // SyntaxError : 식별자가 필요합니다.
```

- 함수 리터럴과 비슷하나 차이점으로는 `이름을 생략할 수 없다`는 점이 있다.
- `표현식이 아닌 문(statement)`이기 때문에 콘솔에서 undefined가 출력된다. 표현식이 맞는 문이었다면 평가되어 함수 자체가 출력되어야 했다.

> 함수 리터럴과 표현식이 아닌 문
> 

자바스크립트 엔진은 함수 리터럴을 중의적으로 해석한다. 기명 함수 리터럴(이름이 있는 함수)은 함수 선언문으로 선언한 함수와 리터럴 표현식으로 선언한 함수 둘 중 하나로 유연하게 해석된다.

- 함수 선언문으로 선언한 함수 : 표현식이 아닌 문으로, 변수에 할당이 불가능하다.
- 리터럴 표현식으로 선언한 함수 : 표현식인 문으로, 변수에 할당이 가능하다.

마치 { } 기호가 언제는 코드 블록으로, 언제는 객체 리터럴로 해석되어 전자는 ; 기호가 필요 없고 후자는 ; 기호가 필요한 것과 비슷하다. 자바스크립트 엔진은 문맥에 따라 값으로 평가될 필요가 있으면 리터럴 표현식으로 선언한 함수로 평가하여 값으로 평가하고(변수에 할당 가능하게 하거나 피연산자로 사용하고), 그럴 필요가 없으면 함수 선언문으로 선언한 함수로 평가한다.

```jsx
// 함수 선언문으로 해석되는 경우
// 기명 함수 리터럴을 단독으로 사용했을 때
function foo() {
    console.log('foo');
}

foo();  // foo

// 함수 리터럴 표현식으로 해석되는 경우
// 함수 리터럴을 피연산자로 사용했을 때
(function goo() {
    console.log('goo');
});

goo();  // ReferenceError: goo is not defined
```

두 방식은 함수 객체를 생성한다는 점에서 동일하지만 호출에 차이가 있다. 위 예제에서 봤듯이, foo는 호출이 가능하지만 goo는 불가능하다.

아까 함수 리터럴에 대해 알아봤을 때, 함수 이름은 **함수 몸체 내에서만** 참조할 수 있는 식별자라고 했다. 즉 함수 외부에서는 함수 이름으로 함수를 참조할 수 없으며, 이를 가능하게 하려면 함수 이름과는 별도로 생성된, 함수 객체를 가리키는 식별자가 필요하다. goo를 참조할 수 없는 이유는 goo라는 함수를 가리키는 식별자가 없기 때문이다. 

> 그렇다면 foo는 무엇일까?
> 

foo로 함수 foo()를 호출하려면 이를 식별자로써 선언하고 할당해야 한다. 그런데 우리는 한 적이 없다. 그저 함수만 선언했을 뿐이다. foo는 무엇일까?

<aside>
❕ 자바스크립트 엔진이  암묵적으로 생성한 식별자

</aside>

자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

즉, 함수는 `함수 이름`으로 호출하는 것이 아니라, `함수 객체를 가리키는 식별자`로 호출한다. 즉, 함수를 호출한 것은 함수 이름 foo가 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자 foo인 것이다.

![function2](https://user-images.githubusercontent.com/97890886/162613660-dbc1fc33-4f9d-4cec-a210-fc1ea6282ae0.png)

결론적으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 할 수 있다. 당연하게도 이 둘이 동일한 원리로 동작하는 것은 아니다. 

- `함수 선언문`은 `표현식이 아닌 문`이기 때문에 값처럼 사용할 수 없지만 자바스크립트 엔진이 암묵적으로 함수 리터럴 표현식처럼 동작하게 한다.
- `함수 표현식`은 `표현식인 문`이기 때문에 값처럼 사용할 수 있다. 함수명 스킵이 가능하며, 함수 표현식으로 선언한 함수 객체를 임의의 식별자에 할당했을 때 식별자로만 호출이 가능하고 함수명으로는 호출이 불가능함에 주의하라.

## 함수 표현식

함수 리터럴로 생성한 함수 객체를 (값처럼 사용하여) 변수에 할당하는 선언 방식.

> 자바스크립트의 함수는 객체 중에서도 일급 객체이다.
> 

일급 객체란 값의 성질을 갖는 객체이다. 변수에 할당되거나, 프로퍼티 값이 되거나, 배열의 요소가 될 수 있음. 즉 함수는 값처럼 자유롭게 사용될 수 있다.

```jsx
// 함수 표현식으로 함수 선언하기
var sum = function add(x,y) {
    return x+y;
};

// 함수 호출 : 함수 객체를 가리키는 식별자
console.log(sum(2,5));  // 7

// 함수 호출 : 함수 이름
console.log(add(2,5));  // ReferenceError: add is not defined
```

# 함수 호이스팅 function hoisting

`함수 선언문`으로 선언된 함수는 함수 호이스팅의 특징을 가지고, `함수 표현식`으로 선언된 함수는 변수 호이스팅의 특징을 지닌다.

## 함수 선언문과 함수 호이스팅

함수 선언문으로 선언된 함수는 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 함수 객체가 미리 생성된다.

즉, 코드가 한 줄씩 순차적으로 실행되기 시작하는 런타임 시점에는 이미 함수 객체와, 함수 이름과 동일한 식별자까지 생성이 완료되어 할당까지 끝난 상태이다. 따라서 함수 선언문 이전에도 함수를 참조하거나 호출할 수 있다. 이것이 바로 `함수 호이스팅`이다.

## 함수 표현식과 변수 호이스팅

함수 호이스팅과 변수 호이스팅은 미묘한 차이가 있다.

함수 표현식으로 선언된 함수 또한 함수 선언문으로 선언된 함수와 마찬가지로 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자가 생성되지만, `변수 키워드(var)`로 선언되었으므로 (변수 호이스팅) 자동으로 undefined로 초기화된다. 함수 객체로 초기화되는 함수 호이스팅과는 다르다.

(함수를 가리키는)변수는 런타임 이전에 평가되지만, (함수 그 자체)변수의 값은 할당문이 실행되는 시점(=런타임)에 평가되므로, 함수 리터럴 또한 런타임에 평가되어 비로소 함수 객체가 된다.

```jsx
// 함수 참조
console.dir(foo);    // [Function: foo]
console.dir(goo);    // undefined

// 함수 호출
console.log(foo(2,3));    // 6
console.log(goo(2,3));    // TypeError: goo is not a function

// 함수 선언 : 함수 선언문
function foo(a,b) {
    return a*b;
}

// 함수 선언 : 함수 표현식
var goo = function (x,y) {
    return x*y;
};
```

> 함수 호이스팅 vs 변수 호이스팅
> 
- 함수 선언문 : 자바스크립트 엔진에 의해 먼저 실행되어 식별자 생성, `함수 객체`로 초기화
- 함수 표현식 : 자바스크립트 엔진에 의해 먼저 실행되어 식별자 생성, `undifined`로 초기화. 함수 객체로 평가되는 것은 **런타임 이후**.

함수 호이스팅은 언뜻 보면 유연해 보이지만 규칙을 무시하는 위험한 요소이다. 또 같은 의미를 가지면서 보다 안정적인 함수 표현식이 이미 존재하므로, 후자를 사용할 것을 권장하는 추세이다.


![function3](https://user-images.githubusercontent.com/97890886/162613665-e2ab8bb9-7fb8-42c7-83f3-f29446db5d05.png)

# Function 생성자 함수

매개변수 목록과 함수 몸체를 문자열로 전달하면서 new연산자와 함께 호출하여 함수 객체를 생성하여 반환한다. 그러나 이 방식은 일반적이지도, 바람직하지도 않으며 클로저closure를 생성하지 않는 등 앞의 두 방식과 다른 원리로 동작한다.

> 생성자 함수
> 

객체를 생성하는 함수. 객체를 생성하는 다양한 함수 中 하나이다.

```jsx
// 3. Function 생성자 함수
var sum = new Function('x', 'y', 'return x+y');
```

# 화살표 함수

ES6에서 도입되었다. 항상 익명 함수(이름 X)로 정의한다. 표현이 상당히 간략화되어 있는데, 실제로 표현뿐만 아니라 내부 동작 또한 간략화되어 있다.

- 생성자 함수로 사용 불가
- 기존 함수와 this 바인딩 방식이 다름
- prototype 프로퍼티가 없음
- arguments 객체를 생성하지 않음

# 함수 호출

함수 호출 시, 현재의 순차적 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮기게 된다.

# 인수 argument와 매개변수 parameter

함수를 실행하기 위해 필요한 값을 함수 외부에서 내부로 전달할 때, 매개변수로 인수를 전달한다.

> 인수
> 
- 값으로 평가될 수 있는 표현식만 허용
- 개수, 타입에 제한 X

> 매개변수
> 
- 함수 정의 시 선언. 함수 내에서 변수와 동일한 취급 (동작 원리도 변수와 유사하다 -함수 호출 시 내부에서 암묵적으로 매개변수가 생성, undefined로 초기화, 순서대로 인수 할당-)
- 스코프(유효 범위): 함수 내부. 함수 내부에서만 참조 가능, 외부에선 불가능.

> 매개변수와 인수의 개수가 일치하는지, 함수는 체크를 하지 않는다.
> 
- 인수를 적게 입력하여 인수가 할당되지 않은 매개변수는 여전히 undefined로 남아있다. 이러한 값으로 연산을 하여 반환을 하게 되면 NaN이 나온다(예시 : 1+undefined = Nan)
- 인수를 많이 입력하여 매개변수보다 더 많아진 경우, 초과된 인수는 무시된다. 그냥 버려지는 것은 아니고, arguments 객체의 프로퍼티로 보관된다.

## 인수 확인

어떤 개발자가 두 개의 숫자 타입 인수를 입력받아 그 합을 반환하려는 함수를 작성하였다.

```jsx
function add(x,y) {
    return x+y;
}

console.log(add(2));    // NaN
console.log(add('a','b'));  // ab
```

그러나 인수로 예상치 못한 값이 넘어오면 의도와는 벗어난 값을 반환하게 된다. 그 이유는 크게 두 가지이다.

1. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다
2. 자바스크립트는 동적 타입 언어이므로, 매개변수의 타입을 사전에 지정할 수 없다.

즉, 함수 내의 코드로 한 번 인수를 확인해 줄 필요가 있다.

```jsx
function add(x,y) {
    if (typeof x !== 'number' || typeof y !== 'number') {
        throw new TypeError('숫자 값만 입력이 가능합니다.');
    }
    return x+y;
}

console.log(add(2));    // NaN
console.log(add('a','b'));  // ab
```

그러나 이렇게 하더라도 부적절한 호출 자체를 사전에 방지할 수 없고, 에러는 런타임에 또 발생하게 된다.  이 때, `argument 객체`를 통해 인수 개수를 확인하거나, `단축 평가`를 사용하여 매개변수에 적절한 기본값(위에서는 0)을 할당하거나, ES6에서 도입된 `매개변수 기본값`을 사용할 수 있다.

```jsx
function add(x,y) {
    x = x || 0;
    y = y || 0;
    return x+y;
}

console.log(add(2));    // 2

// 매개변수 기본값 사용
function add(x=0,y=0) {
    return x+y;
}

console.log(add(2));    // 2
```

## 매개변수 개수

ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지는 않지만, 함수의 의의를 생각했을 때 **매개변수는 가급적 적게** 사용하는 것이 좋다.

매개변수는 순서가 있으므로 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수가 많아지고 이것도 순서를 고려해야 하고 복잡해지고 결과적으로 함수의 사용방법 자체가 어려워진다. 이는 실수를 낳고 유지보수의 어려움을 야기한다.

- 이상적인 매개변수의 개수는 `0개`이며 적을수록 좋다.
- 이상적인 함수란 한 가지 일만 해야 하며 작을수록 좋다.

만약 매개변수가 3개 이상을 넘어간다면, 하나의 매개변수만을 선언하고 객체를 인수로 전달하는 것이 좋다. 이 경우 프로퍼티 키만 정확히 지정해주면 매개변수 순서를 신경쓰지 않아도 된다. 물론, 은총알은 없듯이, 부수 효과(함수 내부에서 객체를 변경하면 함수 외부의 객체도 변경)가 발생한다는 한계가 있다.

# 반환문

return 키워드 + 표현식(반환값)으로 이루어져 있으며 함수의 실행 결과를 함수 외부로 반환한다.

- 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.
- 반환문을 생략해도 암묵적으로 undefined가 반환된다.

함수 호출문 역시 표현식이므로, return 으로 반환한 표현식의 평가 결과(반환값)로 평가된다.

> 반환문의 역할
> 
1. 함수의 실행을 중단하고 함수 몸체를 빠져나간다
2. return 키워드 뒤에 오는 표현식을 평가해 반환한다.

함수는 함수의 마지막 문 또는 반환문이 실행되면 종료한다. 즉 반환문은 함수의 끝을 알리는 문이기도 하다.

# call by reference와 부수 효과

함수를 호출하면서 매개변수에 값을 전달하는 방식 중 하나. 매개변수도 함수 내부에서 변수와 동일하게 취급되므로 타입에 따라 call by value냐, call by reference냐가 갈린다.

다음 코드는 원시 타입과 객체 타입을 각각 받아 함수 내부에서 값을 변경하는 예제이다.

```jsx
function changeVal(primitive, obj) {
    primitive += 10;
    obj.name = 'Kang';
}

// 외부 상태
var num = 5;
var person = {
    name: 'Lee',
};

// 원시 값 : call by value
// 객체 : call by reference 
changeVal(num, person);

// 원시 값은 원본 훼손 X
// 객체 값은 원본 훼손 O
console.log(num, person);   // 5 { name: 'Kang' }
```

> 부수 효과
> 

객체 타입 인수는 원시 타입 인수와 달리, 값 자체가 복사되어 전달되는 것이 아니고 참조 값이 복사되어 매개변수에 전달된다. 

![call-by-reference](https://user-images.githubusercontent.com/97890886/162613752-bbcb5622-bd6c-471c-8c0b-7121bde7a9bb.png)

이러한 현상이 발생하는 이유는 두 가지이다.

1. 객체는 변경할 수 있는 값이다
2. 참조에 의한 전달 방식으로 동자간다

이러한 현상을 해결하는 방법은

- 옵저버 Observer 패턴을 사용하여 객체 참조를 고유하는 모든 식별자에게 변경 사실을 통지, 관리한다.
- 객체를 불변 객체로 만들어 사용한다. 변경이 필요한 경우 객체를 방어적 복사(깊은 복사)하여 완벽히 똑같은 객체를 새로 생성하고 재할당을 통해 교체한다.

> 순수 함수


외부 상태(원본)를 변경하지 않고 외부 상태에 의존하지도 않는 함수. 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이는 패러다임이 바로 `함수형 프로그래밍`이다.

# 다양한 함수의 형태

## 즉시 실행 함수

그룹 연산자 ()로 함수를 묶어 함수 리터럴을 평가하여 함수 객체를 생성하는 방식으로 선언한다. (꼭 그룹 연산자가 아니어도 함수 리터럴을 평가할 수 있다면 ok. 그룹 연산자가 편해서 쓴 것.)함수 정의와 동시에 즉시 호출되는 함수이다. 단 한 번만 호출 가능하며, 다시 호출할 수 없다.

일반적으로는 익명 함수(이름X)를 사용하지만, 기명 함수도 사용 가능하다. 함수의 이름은 함수 내에서만 참조할 수 있는 식별자이므로 이를 사용하여 다시 호출할 수 없다.

```jsx
(function () {
    var a = 2;
    var b = 3;
    return a * b;
}());
```

일반 함수처럼 값을 반환하거나 인수를 전달할 수 있다.

```jsx
// 즉시 실행 함수도 반환할 수 있어!
var sum = (function () {
    var x = 3;
    var y = 5;
    return x * y;
}());

console.log(sum);   // 15

// 즉시 실행 함수도 매개변수에 인수 전달할 수 있어!
var sum = (function (x, y) {
    return x * y;
}(3,5));

console.log(sum);   // 15
```

즉시 실행 함수 내에 코드를 모아 두면 이름 충돌을 방지할 수 있다. 이 함수의 장점에 대해서는 추후 자세히 배워 보자. (→ 전역 변수의 사용을 억제하는 방법)

## 재귀 함수

자기 자신을 호출(재귀 호출 recursive call)하는 함수. 반복되는 동작을 반복문 없이 구현할 수 있다.

```jsx
// 반복문
function countdown(n) {
    for (var i = n; i>=0; i--) console.log(i);
    console.log('BOMB!');
}
countdown(10);

// 재귀함수
function countdown(n) {
    if (n<0) return 'BOMB!';
    console.log(n);
    countdown(n-1);
}
countdown(10);
```

함수 내부에서는 함수 이름을 사용할 수 있으므로, 함수 이름으로 자기 자신을 호출할 수 있는 원리를 사용했다.

- 기본 무한 반복이기 때문에, 재귀 함수 내에 탈출 조건을 반드시 만들어야 한다. (없을 시 스택 오버플로 발생)
- 반복문과 유사한 구조 때문에 대부분은 for이나 while로 구현 가능하다.

재귀 함수를 써야만 직관적으로 보일 때 한정적으로 사용한다. 실수하면 스택 오버플로가 난다구.

## 중첩 함수

함수 내부에 정의된, 함수 안의 함수. 이 때 중첩 함수를 포함하는 부모 함수를 외부 함수라고 한다. 일반적으로 외부 함수의 역할을 돕는 헬퍼 역할을 한다. ES6부터 함수 정의가 훨씬 유연하게 변했다(for, if문에서도 정의할 수 있을 정도이다;;). 물론 편해진 만큼? 호이스팅 때문에 혼란이 일어날 수 있으니?? 안하느게 좋다~

```jsx
function outer() {
    var x = 1;

    function inner() {      // 단, 무조건 외부 함수 내에서 '사용(호출)'되어야 함
        var y = 2;
        console.log(x + y);     // 외부 함수의 변수 참조 가능
    }
    inner();    // 3
}
outer();
```

## 콜백 함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수. 

```jsx
// 0부터 n까지 출력하는 코드
function repeat(n) {
    for (var i=0; i<n; i++) console(i);
}

repeat(10);
```

이 함수는 0부터 n까지의 수를 출력한다. 만약 여기에 조건이 추가된다면? 그러니까, 짝수만을 출력하고 싶다면? 함수를 수정해야 한다. 그런데 이후 홀수만을 출력하거나, 3의 배수만을 출력하고 싶다는 오퍼가 계속해서 들어온다면? 함수를 통째로 수정하여 새롭게 다시 정의해야 할 것이다.

```jsx
// 콜백 함수를 활용하기
// 기본 로직 함수
function repeat(n,f) {
    for (var i=0; i<n; i++) {
        f(i);
    }
}

// 부가기능 함수1 : 전부 출력하기
var logAll = function(i) {
    console.log(i);
};

// 부가기능 함수2 : 홀수만 출력하기
var logOdd = function(i) {
    if (i%2) {
        console.log(i);
    }
};

repeat(5, logAll);     // 0 1 2 3 4
repeat(5, logOdd);     // 1 3
```

이러한 “추가기능을 수행하는 함수”를 콜백함수로 만들어, 고차 함수(부모)에게 인자로 전달하면 1차로 이미 부가 조건에서 걸러진(추가기능이 수행된)함숫값만이 원본 함수에게 들어오게 된다.

함수의 변하지 않는 공통 로직은 미리 정의해 두고, 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 내부로 전달하는 것이다.

콜백 함수는 중첩 함수와 비슷하게 헬퍼의 역할을 한다. 그러나 중첩 함수보다 더 좋은 점은, 중첩 함수는 완벽하게 종속되므로 고정되어 있어 교체하기 곤란하지만 콜백 함수는 자유롭게 교체할 수 있다는 장점이 있다. 고차 함수는 콜백 함수를 자신의 일부분으로 합성하여 동작한다.

콜백 함수를 일단 arguments로 받으면 호출 시점을 자신이 원하는대로 정할 수 있다.

> 일회용 vs 다회용
> 

콜백 함수를 정의와 동시에 곧바로 고차 함수에 전달한다. 따로 정의하지 않고 그냥 바로 넣는거다. 콜백 함수는 고차 함수에 의해 호출되므로 **고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.**

```jsx
// 특정 고차 함수에만 사용되는 경우

// 콜백 함수는 익명 함수 리터럴이다.
// 호출될 때마다 평가되어 함수 객체를 생성하는 형식이다.

repeat(5, function(i) {
    if (i%2) console.log(i);
});

// 다른 곳에서도 호출할 필요가 있거나, 고차 함수가 자주 호출되는 경우

// 콜백 함수는 사전에 정의한 함수이다.
// 함수 객체로써 단 한번만 생성된다.

var logOdds = function(i) {
    if (i%2) console.log(i);
};

repeat(5, logOdds);
```

## 순수 함수와 함수형 프로그래밍

> 순수 함수
> 

어떤 외부 상태(전역 변수, 서버 데이터, 파일, Console, DOM)에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수. 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존하며, 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.

- 일반적으로 최소 하나 이상의 인수를 전달받는다. (인수를 전달받지 않는다면 그냥 계속 같은 값만 반환하니까 상수와 다를 게 없다.)
- 인수의 불변성을 유지한다. (인수를 변경할 수 없다)
- 함수의 외부 상태를 변경하지 않는다.

```jsx
var count = 0;

// 순수 함수
function increase(n) {
    return ++n;
}

// 순수 함수가 반환한 값을 변수에 재할당하여 상태 변경
count = increase(count);
console.log(count);     // 1
```

> 비순수 함수
> 

함수의 외부 상태에 따라 반환값이 달라진다(함수 외부 상태에 의존). 부수 효과(함수의 외부 상태를 변경)가 있다.

- 인수를 전달받지 않고, 함수 내부에서 외부 상태를 직접 참조한다. 이는 다음과 같은 문제점을 발생시킨다.
1. 외부 상태에 의존하게 됨 : 외부 상태가 변경되면 반환값이 예기치 못하게 변할 수 있다.
2. 부수 효과 : 외부 상태(원본)을 훼손시킴.

함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다. 따라서 함수 외부 상태의 변경을 지양하는 **순수 함수**를 사용하는 것이 좋다.

> 함수형 프로그래밍
> 

`순수 함수`와 `보조 함수`의 조합으로 부수 효과를 최소화하여 불변성을 지양한다.

- 로직 내에 존재하는 조건문과 반복문을 제거 : 복잡성 해결
- 변수 사용을 억제하거나 생명주기를 최소화 : 상태 변경을 피해 오류를 최소화
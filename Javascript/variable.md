# variable

하나의 값을 저장하기 위해 확보한 메모리 공간 자체, 또는 그 메모리 공간을 식별하기 위해 붙인 이름. 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, 값의 위치를 가리키는 상징적인 이름.

![varaible](https://user-images.githubusercontent.com/97890886/161385029-a3dc30ec-aafb-43af-a8e6-0fba4d349d27.png)


변수명을 비롯한 모든 식별자는 “실행 컨텍스트”에 등록된다.

## 실행 컨텍스트

<aside>
❕ 자바스크립트 엔진이 소스코드를 평가, 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역. 식별자와 스코프가 이곳에서 관리되며, 변수명과 변수 값은 실행 컨텍스트 내에 키 + 값 형식인 객체로 등록되어 관리된다.

</aside>

# 변수 선언 variable declaration

> 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름(identifier)과 확보된 메모리 공간의 주소를 연결(name binding)하여 값을 저장할 수 있게 준비한다.

```jsx
let currentTempC = 22;    // 섭씨 온도
```

섭씨 온도를 나타낼 변수 currentTempC를 선언하고 초깃값을 할당하였다. 물론 언어에는 “이 변수는 섭씨 온도만을 저장하는 변수이다”라고 규칙을 강제할 수 있는 기능은 없지만, 사람이 보고 얼추 의미나 기능을 판단할 수 있게 변수명을 짓는 것이 좋다.

```jsx
let targetTempC;    // 초깃값 할당되지 않음. undefined가 할당됨
```

변수 선언 시 초깃값을 할당하지 않으면 undefined(불확실)가 할당된다.

```jsx
let targetTempC, room1 = "conference_room_a", room2 = "lobby";
```

한 행의 코드에 변수 여러개를 선언할 수 있다. room1과 room2는 문자열(text) 변수이다.

# 변수 호이스팅 variable hoisting

변수 선언문보다 변수 참조문이 위에 있다면, 일반적인 프로그래밍 언어는 오류가 난다. 그러나 자바스크립트는 허용된다. 왜일까?

> 자바스크립트는 변수 선언이 런타임(runtime)이 아니라 그 이전 단계에서 먼저 실행된다.

런타임이란 소스코드가 한 줄씩 순차적으로 실행되는 시점이다. 자바스크립트는 런타임에 앞서, 먼저 소스코드의 평가 과정에서 소스코드를 실행하기 위한 준비를 하므로 이 때 자바스크립트 엔진은 모든 선언문을 먼저 실행시킨다. 이렇게 변수 선언문이 마치 코드의 앞줄로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징이 바로 variable hosting이다.

# 값 할당 assignment

```jsx
var score;    // 변수 선언
score = 80;   // 값 할당
```

변수 선언과 값 할당을 하나의 문(statement)로 단축 표현할 수도 있지만, 자바스크립트 엔진은 내부적으로 항상 이를 2개의 문으로 분리하여 각각 실행한다.

> 변수 선언과 값 할당의 실행의 시점은 다르다.

- 변수 선언 → 런타임 이전에 먼저 실행
- 값 할당 → 런타임에 실행

변수에 값을 할당할 때에는 이전 값(undefined)가 저장되어 있던 공간에 덮어쓰는 것이 아니라, 새로운 메모리 공간을 확보하고 그곳에 값을 할당한다.


# 값 재할당

변수에 값을 재할당하면 변수의 값이 변경된다. 처음 값을 할당할 때와 마찬가지로, 이전 값이 저장되어 있던 메모리 공간을 지우고 덮어쓰는 것이 아니라 새로운 메모리 공간을 확보하고 새로운 값을 저장하는 구조이다. 이 때 이전 값들과 undefined는 어떤 식별자와도 연결되어 있지 않게 된다.(==어떤 식별자도 참조하지 않는 메모리 공간)

## 가비지 콜렉터 garbage collector

애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제 release하는 기능. 자바스크립트는 매니지드 언어-가비지 콜렉터가 내장되어 있다-로서 가비지 콜렉터로 메모리 누수 memory leak를 방지한다.

## 매니지드 언어 managed language

프로그래밍 언어는 메모리 관리 방식에 따라 매니지드 언어와 언매니지드 언어로 분류할 수 있다.

- 매니지드 언어 : 개발자가 명시적으로 메모리를 할당하고 해제 (C언어)
- 언매니지드 언어 :  메모리 관리 기능을 언어 차원에서 담당. 개발자의 직접적인 메모리 제어 비허용.

개발자의 역량에 따라 최적의 성능을 확보하거나, 일정한 생산성을 확보하거나.

# 식별자 네이밍 규칙

1. 특수문자를 제외한 문자, 숫자, 언더스코어, 달러 기호 포함 가능
2. 문자, 숫자, 언더스코어, 달러기호 中 하나로 시작해야 함. 숫자는 X
3. 예약어 사용 불가능

- 변수, 함수 이름 : 카멜 케이스 firstName
- 생성자 함수, 클래스 이름 : 파스칼 케이스 FirstName


# constant

ES6의 새로운 기능이다. 변수처럼 값을 할당받을 수 있지만, 변수와 달리 할당한 값을 바꿀 수 없다.

```jsx
const ROOM_TEMP_C = 21.5, MAX_TEMP_c = 30;
```

상수를 사용하여 쾌적 온도의 최솟값과 최댓값을 지정하였다. 상수 이름으로는 대문자와 언더바(_)만 사용하는 것이 일반적이다.

# 변수 vs 상수?

자바스크립트에서는 변수보다 상수를 써야 한다. 데이터의 값이 유동적인 것 보다는, 고정적이면 이해하기 쉽다. 즉 ‘바뀌지 말아야 할 데이터 값을 실수로 바꾸는 일’이 줄어든다. 이건 C++에서도 const의 기능으로 배운 적이 있다! 물론 다양한 상황이 있다. loop 제어나, 시간에 따라 값이 바뀌는 경우 등 데이터의 값이 바뀌는 것이 자연스럽다면 변수를 사용해도 된다. 그러나 일단 상수를 먼저 쓰는 습관을 들이면, 변수가 필요한 상황이 생각보다 훨씬 적은 것을 알 수 있을 것이다.

# identifier

변수, 상수, 함수의 이름을 식별자(identifier)라고 한다.

> 식별자 규칙
> 
- 글자, $, _ 로 시작할 것
- 글자, 숫자, $, _ 만 사용 가능
- 유니코드 문자 허용
- 예약어는 사용 불가능

다른 언어와는 달리 자바스크립트는 $를 특수문자로 사용하지 않고 식별자 이름에 사용할 수 있다.

> 식별자 표기법
> 
- camel case (카멜 케이스)

낙타. 소문자 사이에 대문자를 끼워넣어 의미를 구분한다.

- snake case (스네이크 케이스)

언더바(_)를 사용하여 의미를 구분한다. 

> 주의사항
> 
- 식별자는 대문자로 시작하는 것이 불가능하다. 예외는 클래스 뿐
- _로 시작하는 식별자는 아주 특별한 상황이거나, ‘내부’ 변수에서만 사용하므로 일반적인 경우라면 되도록이면 _로 시작하지 않을 것을 권장한다.
- jQuery를 사용할 경우, $로 시작하는 식별자는 보통 jQuery 객체라는 의미이다.

# literal

값을 프로그램 안에서 직접 지정한다는 의미. 자바스크립트는 프로그래머가 제공한 리터럴 값을 받아 데이터를 만든다. identifier과 literal을 잘 구분하는 것이 중요하다. 값을 보관할 메모리 박스와, 값 자체의 의미이니 어렵지는 않다.

```jsx
let room1 = "conference_room_a";
```

위 예시(room1에 "conference_room_a"을 할당한 경우)에서 room1은 변수를 가리키는 identifier이다. "conference_room_a"는 문자열 literal인 동시에 room1의 value이다.

```jsx
let room1 = "conference_room_a";    // 변수 room1(식별자)에 리터럴 값 할당
let currentRoom = room1;            // 변수 currentRoom(식별자)에 변수 room의 리터럴 값 할당
currentRoom = conference_room_a;    // Error! conference_room_a 라는 식별자를 찾을 수 없음
```

되도록이면 리터럴보다는 상수, 변수를 쓰는 것이 좋다. 예를 들어, 보일러 프로그램을 만든다고 치자. 적정 온도인 21.5를 리터럴로 표기해도 되지만, 만약 이 값이 100번 1000번 쓰인다면? 상수 ROOM_TEMP_C를 쓰는 것이 유지보수에 좋을 것이다. 만약 사람마다 적정 온도를 입력받아 사용하게 하고 싶다면 변수를 쓰는게 나을 수도 있다.

# var, let 그리고 const

let과 var 전부 변수를 뜻하고, const는 상수이다.

## var

```jsx
var name = 'bathingape'
console.log(name) // bathingape

var name = 'javascript'
console.log(name) // javascript
```

선언을 이미 했는데도 불구하고, 다시 선언했을 때 에러가 뜨지 않고 다른 값을 가졌다. 좋게 말하면 유연하지만, 나쁘게 말하면 혼란이다.

## let

```jsx
let name = 'bathingape'
    
let name = 'javascript'
console.log(name) 
// Uncaught SyntaxError: Identifier 'name' has already been declared

name = 'react'
console.log(name) //react
```

선언을 이미 한 경우 다시 선언하려고 할 때 에러가 난다. 당연하지만, 불변 값(상수)이 아니므로 다른 값을 할당할 수 있다. 선언을 다시 할 때 에러가 날 뿐이다.

## const

```jsx
const name = 'bathingape'
console.log(name) // bathingape

const name = 'javascript'
console.log(name) 
// Uncaught SyntaxError: Identifier 'name' has already been declared

name = 'react'
console.log(name) 
//Uncaught TypeError: Assignment to constant variable.
```

상수의 경우 재선언, 재할당 전부 불가능하다.
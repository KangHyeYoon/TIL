# var 키워드의 한계

ES5까지는 변수를 선언할 수 있는 방법이 var이 유일했다.

## 변수 중복 선언 허용

동일한 이름의 변수가 이미 선언되어 있는 것을 모르고 변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수 값이 변경하는 부작용이 발생한다.

- 초기 할당값이 있는 선언문이 이미 있을 때 → var 키워드가 없는 것처럼 동작
- 초기 할당값이 없는 선언문이 이미 있을 때 → 선언문 자체를 무시

## 함수 레벨 스코프

var로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하기 때문에, 다른 코드 블록(if, for, while문 등) 내에서 선언해도 모두 전역 변수 취급을 받는다. 즉 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높여 의도치 않게 전역 변수가 중복 선언되면 위와 같은 부작용이 생기게 된다.

## 변수 호이스팅

var로 변수를 선언하면 변수 선언문 이전에 변수를 참조해도 변수 호이스팅에 의해 에러가 발생하지 않는다. 이는 프로그램의 흐름상 맞지 않고, 가독성을 떨어뜨리며 오류를 발생시킬 여지를 남길 수도 있다.

# let 키워드

ES6에서 도입되었으며, var 키워드의 단점을 보완하기 위한 새로운 변수 선언 키워드이다.

## 변수 중복 선언 금지

let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러 SyntaxError가 발생한다.

## 블록 레벨 스코프

let 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다. 함수 내에 코드 블록이 있는 경우, 이는 함수의 지역 스코프에 중첩된다.

## 변수 호이스팅

let 키워드로 선언한 변수는 변수 **호이스팅이** **발생하지 않는 것처럼** 동작한다.

> var 키워드와 변수 호이스팅
> 

![var](https://user-images.githubusercontent.com/97890886/162730863-7980fde2-6d43-4fb4-b4fc-ccaaef1ca050.png)

var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 `선언`단계와 `초기화`단계가 한 번에 진행된다.

- 선언 : 스코프(실행 컨텍스트의 렉시컬 환경)에 변수 식별자를 등록하여 자바스크립트 엔진에게 변수의 존재를 알림
- 초기화 : 즉시 undefined로 변수를 초기화한다

그래서 변수 선언문 이전에 변수에 접근해도 스코프에 변수가 존재하기 때문에 Reference Error가 발생하지 않고 undefined를 반환한다.

> let 키워드와 변수 호이스팅
> 

![let](https://user-images.githubusercontent.com/97890886/162730934-afed3a02-5a7d-4f3d-8c80-ec11bbf68b5b.png)

let 키워드로 선언한 변수는 `선언`단계와 `초기화`단계가 분리되어 진행된다. 런타임 이전에 선언 단계가 암묵적으로 진행되지만 초기화 단계 이후부터는 변수 선언문에 도달했을 때(런타임) 실행된다. 즉, 스코프의 시작 지점부터 초기화 시작 지점까지 `변수를 참조할 수 없다.` 이것이 바로 **일시적 사각지대(TDZ)** 이다.

let 키워드는 변수 호이스팅이 발생하지 않는 것처럼 보이지만, 그렇지 않다.

```jsx
let foo = 1;    // 전역 변수

{
    console.log(foo);    // Reference Error
    let foo = 2;    // 지역 변수
}
```

만약 호이스팅 자체가 없었다면, 3행의 코드가 에러가 나지 않고 전역 변수 1을 참조할 수 있었어야 했다. 그러나 오류가 났으니, 호이스팅 자체는 일어나는 것을 알 수 있다. 단지 일어나지 않는 것 처럼 동작할 뿐...

>> 추가 : 스코프 검색에 의한 원리이다.

- 호이스팅 자체가 일어나지 않았을 경우 : 지역 변수 foo를 ‘아예’찾지 못함. 스코프 검색의 원리로 상위(전역)로 이동하여 전역 객체를 찾아서 참조
- 호이스팅 자체는 일어났으나, 선언과 초기화가 동시에 되지 않고(이 경우 참조가 가능하며 undefined가 나옴)일시적 사각지대에 위치해 있기 때문에 지역변수 foo를 찾긴 했으나 참조를 못하는 상태.... 그래서 에러가 뜸.

## 전역 객체의 프로퍼티가 아니다.

var 키워드로 선언한 전역 변수, 전역 함수 등은 전부 전역 객체 window의 프로퍼티가 되어 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.

그러나 let 키워드로 선언한 전역 변수는 전역 객체 프로퍼티가 아니다.

let 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재한다.

# const 키워드

상수constant를 선언하기 위해 사용하지만, 반드시 상수만을 위해 사용되지는 않는다(이에 대해선 추후 설명). let과 상당히 유사한 특징을 지니므로, let과의 차이점을 중심으로 알아보자.

## 선언과 초기화

반드시 `선언과 동시에 초기화` 해야 한다. 그렇지 않으면  문법 에러가 발생한다.

let과 유사하게 블록 레벨 스코프를 가지고, 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

## 재할당 금지

중복 안 된다. 재할당도 안 된다. 

> 상수
> 

const 키워드로 선언한 변수에 `원시 값`을 할당한 경우, 변수 값을 변경할 수 있는 방법이 없다. 원시 값은 변경 불가능한 값이므로 재할당 없이는 값을 변경할 수 없으니까. 재할당도 막히면 끝난거지. 이러한 특징 때문에 const 키워드는 거의 상수 표현을 위해 쓰인다.

상수는 상태 유지, 편의성, 유지보수의 편의 등을 위해 적극적으로 사용해야 한다. (변수보단 상수!)

일반적으로 상수의 이름은 `대문자`로 선언해 상수임을 명확히 나타내고, 언더스코어를 사용하여 `스네이크 케이스`로 표현하는 것이 일반적이다.

> 객체
> 

const 키워드로 선언한 변수에 `객체`를 할당한 경우 값을 변경할 수 있다. 원시 값은 값 자체도 변경 못 하고(불변값), 재할당도 금지됐었기 때문에 완전 원천봉쇄였는데 객체는 재할당이 없어도 값 자체를 변경할 수 있기 때문이다. 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경 등... 

당연히 객체가 변경되더라도 변수에 할당된 참조 값이 변하는 것은 아니다.

# 무엇을 사용해야 하는가?

- `대부분의 경우`  에 변수보다 상수(const)를 권장한다.
- 변경이 발생하지 않고, 읽기 전용으로 사용하는(재할당이 필요 없는) 원시 값과 객체에는 const를 사용한다.
- 재할당이 필요한 경우에 한정해 let 키워드를 사용하되, 변수의 스코프는 최대한 좁게 만든다.
- var 은 사용하지 않는다.
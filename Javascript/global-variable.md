# 전역 변수

전역변수의 무분별한 사용은 위험하므로, 반드시 사용해야 할 경우를 제외하고는 사용하지 않는 것이 좋다.

# 변수의 생명 주기 life cycle

변수는 `선언`에 의해 생성되고 `할당`을 통해 값을 갖으며, 언젠가 소멸한다. 

## 지역변수

변수 선언은 선언문이 어디에 있든 `호이스팅`에 의해 런타임 이전에 먼저 실행된다. 그러나 엄밀히 말하자면 이는 **전역변수** 한정으로, **지역변수**는 함수가 호출된 직후에 함수 몸체가 순차적으로 실행되기 전에 먼저 실행된다. 원리는 똑같은데 이제 범위가 다른...

```jsx
function foo() {
    var x = 'local';
    console.log(x);
    return x;
}

foo();
console.log(x);    // 에러
```

foo 함수를 호출하면

1. 함수 런타임 이전에 x변수의 선언문이 가장 먼저 실행되어 지역변수 x가 선언되고, undefined로 초기화된다.
2. 함수 몸체의 문들이 순차적으로 실행된다.
3. 함수가 종료되면 지역변수 x는 소멸된다.

> 지역 변수의 생명 주기 === 함수의 생명 주기
> 

대부분 일치하지만, 지역 변수가 함수보다 오래 생존하는 경우도 있다. 이는 메모리 공간에서의 변수의 메커니즘과 깊은 관련이 있다.

엄밀히 말하자면, 변수의 생명 주기는 메모리 공간이 `확보`된 시점 ~ 메모리 공간이 `해제`되어 가용 마모리 풀에 반환되는 시점까지다.

함수 내부에서 선언된 지역 변수는 함수 스코프에 등록되며(렉시컬 환경), 이 스코프가 소멸(메모리 해제)될 때까지 유효하며, 메모리가 해제된다는 말의 의미는 더 이상 누구도 그 메모리를 참조하지 않는다는 것이다(이 때 가비지 콜렉터에 의해 해제되어 반환된다). 그래서 일반적으로 변수의 생명 주기와 함수의 생명 주기는 일치하는 편이지만, 누군가가 계속해서 스코프를 참조한다면 스코프는 생존하게 된다. → 자세한 내용은 `클로저`에서

> 호이스팅은 스코프 단위로 동작한다.
> 

```jsx
console.log(x);     // undefined (전역 변수 호이스팅)

var x = 'global';

function foo() {
    console.log(x);     // undefined (지역 변수 호이스팅)
    var x = 'local';
}

foo();
console.log(x);     // global (전역 변수 정상적 참조)
```

- 전역 변수의 호이스팅 : 변수의 선언이 전역 스코프의 선두로 끌어 올려진 것처럼 동작한다.
- 지역 변수의 호이스팅 : 변수의 선언이 함수(지역) 스코프의 선두로 끌어 올려진 것처럼 동작한다.

즉, 호이스팅이란 변수 선언이 `스코프`의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징인 것이다. 

## 전역변수

함수와 달리, 전역 코드는 진입점(함수 호출이나, C언어에서의 main함수 등-entry point-)이 없으며 코드가 로드되자마자 곧바로 해석되고 실행된다. 또 끝을 암시하는 문(함수에서는 반환문 등)도 없기 때문에 더 이상 실행될 문이 없을 때 종료된다. 즉 명시적인 호출이 없이 그냥 바로 실행되는 것이다.

var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되며, 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.

> 전역 객체
> 

코드 실행 전, 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체. 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미한다. (저번에 현재 위치를 참조하는 this에 대해 공부할 때 전역 객체에서는 window가 나왔던 기억이 난다!!)

전역 객체를 가리키는 식별자는 여러가지였으나, ES11 이후 globalThis로 통일되었다.

전역 객체의 프로퍼티 : 표준 빌트인 객체(Number, Object, Function, Array...), 환경에 따른 호스트 객체(클라이언트 Web API 또는 Node.js의 호스트 API), var 키워드로 선언한 전역 변수와 전역 함수

> var 키워드로 선언한 전역 변수의 생명 주기 === 전역 객체의 생명 주기
> 

브라우저 환경에서 전역 객체는 windows이므로, 브라우저 환경에서 var 키워드로 선언한 전역 변수는 전역 객체 windows의 프로퍼티이다. windows는 웹 페이지를 닫기 전까지 유효하기 때문에 전역 변수의 생명 주기 또한 웹 페이지를 닫을 때 까지이다.

# 전역 변수의 문제점

## 암묵적 결합

전역 변수의 의도는 코드 어디서든(전역) 참조하고 할당할 수 있는 변수를 사용하겠다는 것이며, 이는 곧 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합 implicit coupling을 허용하는 것이다. 편한 코드는 항상 위험하고, 신뢰도가 낮았듯이, 변수의 유효 범위(스코프)가 클수록 코드의 가독성은 나빠지며 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.

## 긴 생명 주기

전역 변수는 프로그램이 끝날 때까지 살아있으므로, 생명 주기가 아주 길고, 이는 곧 메모리 리소스도 오랜 기간 동안 소비함을 의미한다. 전역 변수의 상태를 변경할 수 있는 시간도, 기회도 많다. 게다가 var 키워드는 변수의 중복 선언까지;; 허용하기 때문에 실수로 중복된 이름의 변수를 선언하면 의도치 않게 재할당이 이뤄질 위험이 있다.

## 스코프 체인 상에서 중점에 존재

전역 객체는 스코프 체인 상에서 가장 상위 요소이다. 즉 변수를 검색할 때 전역 변수가 가장 마지막에 검색되며, 전역 변수의 검색 속도가 제일 느리다. 물론 미미한 차이지만, 속도차는 분명히 존재한다.

# 전역 변수 사용을 억제하기

> 변수의 스코프는 좁을수록 좋다
> 

전역 변수를 반드시 사용해야 할 이유를 찾지 못한 경우 지역 변수를 사용하는 것이 좋다. 

## 즉시 실행 함수

즉시 실행 함수는 함수 정의와 동시에 호출되며, 단 한 번만 사용(호출)된다. 이 성질을 이용하여 전역 코드를 즉.실.함의 코드로 만드는 방법이다. 모든 코드를 즉시 실행 함수로 감싸면 내부의 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

## 네임스페이스

전역의 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.

```jsx
// 네임스페이스 사용하기

var MYAPP = {};

MYAPP.name = 'kang';

console.log(MYAPP.name);    // kang

// 계층적 네임스페이스 구성

var MYAPP = {};

MYAPP.person = {
    name: 'kang',
    age: 22,
};

console.log(MYAPP.person.name);     // kang
```

네임스페이스를 분리하면 식별자 충돌을 방지하는 효과는 있으나 네임스페이스 객체 자체가 전역 변수에 할당되는 형식이기 때문에 한계를 피할 수 없다.

## 모듈 패턴

관련성이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 패턴(어느정도 클래스를 모방한 것이다). 클로저를 기반으로 동작한다. 클로저는 자바스크립트의 아주 강력한 기능이다!

> 특징
> 
- 전역 변수 억제 가능
- 캡슐화까지 구현 가능!

> 캡슐화 (encapsulation)
> 

객체의 상태(state)를 나타내는 프로퍼티와 메서드(프로퍼티를 참조하고 조작할 수 있는 동작)를 하나로 묶는 것. 정보 은닉(information hiding - 객체의 특정 프로퍼티, 메서드 숨기기)의 역할도 한다.

대부분의 객체지향 프로그래밍 언어는 클래스를 구성하는 멤버에 대해 public, private, protected 등의 `접근 제한자(acces modifier)`를 제공하여 원하지 않는 외부의 접근으로부터 내부를 보호하고 제한된 접근만을 제공한다. 그러나 자바스크립트는 접근 제한자를 제공하지 않으므로 한정적이지만 `모듈 패턴`을 통해 전역 네임스페이스의 오염을 막는다.

```jsx
// 모듈화

var Counter =
    (function() {
        // private 역할 : 반환하지 않는다
        var num = 0;

        // public 역할 : 반환문 사용
        return {
            increase() {
                return ++num;
            },
            decrease() {
                return --num;
            }
        }
    }());

// private 변수는 외부로 노출되지 않는다
console.log(num);   // ReferenceError: num is not defined

// public 문은 외부에서 접근할 수 있다
console.log(Counter.increase());    // 1
console.log(Counter.decrease());    // 0
```

## ES6 모듈

> ES6 모듈은 파일 자체의 `독자적인 모듈 스코프`를 제공한다.
> 
- 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수도, windows 객체의 프로퍼티도 아니다.
- script 태그에 type=”module” 어트리뷰트를 추가하면, 로드된 자바스크립트 파일은 모듈로서 동작한다.
- 모듈의 파일 확장자는 .mjs를 권장한다.
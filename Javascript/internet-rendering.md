# 브라우저의 렌더링 과정

> 브라우저는 어떻게 웹 문서를 사용자에게 보여주는가?
> 

브라우저(client)는 필요한 리소스(여러 정적 파일 또는 서버가 동적으로 생성한 데이터 : HTML, CSS, JS, 이미지, 폰트 등)를 서버에 `요청`하고 서버로부터 `응답`받아 시각적으로 렌더링한다.

1. 브라우저 <— HTML, CSS, JS 렌더링에 필요한 리소스—> 서버
2. 브라우저의 렌더링 엔진: 서버로부터 응답된 HTML, CSS —파싱—> DOM, CSSDOM 생성 —결합—> 렌더 트리 생성
3. 브라우저의 자바스크립트 엔진: 서버로부터 응답된 JS —파싱—> AST 생성 —> 바이트코드로 변환 후 실행 (자바스크립트는 DOM API를 통해 DOM, CSSDOM을 변경할 수 있다)
4. 렌더 트리를 기반으로 HTML 레이아웃을 계산 —> 브라우저 화면에 페인팅 

## 파싱(parsing)

문서의 텍스트를 어휘 분석(exical analysis, 문자열을 토큰으로 분해)하고 이에 문법적 의미와 구조를 반영하여 파스 트리(syntax tree, 트리 구조의 자료구조)를 생성하는 과정. 파싱이 완료되면 파스 트리를 기반으로 바이트코드(bytecode, 중간 언어)를 생성 및 실행한다.

## 렌더링(rendering)

HTML, CSS, JS 문서를 파싱하여 브라우저에 시각적으로 출력하는 것

## 0. 브라우저↔서버 간 요청과 응답

브라우저의 주소창에 `URL`을 입력하고 엔터를 누르면 URL의 `호스트명`이 `DNS`를 통해 `IP 주소`로 변환되고 → 이 IP주소를 갖는 서버에게 요청을 전송한다.

서버는 루트 요청에 대해 암묵적으로 서버의 루트 폴더에 존재하는 정적 파일 `index.html` 을 응답한다. 즉 명확한 리소스 요청 내용이 없는 [http://naver.com](http://naver.com) 은 [http://naver.com](http://naver.com)/index.html 과 같은 요청이며, 우리가 네이버에 ‘방문’ 하는 요청(주소창에 url 입력 후 엔터)은 정확히 말하면 특별한 리소스 요청이 없지만 서버가 암묵적으로 반환한 네이버의 index.html이라는 정적 웹 파일이다.

index.html이 아닌 다른 정적 파일을 서버에 요청하려면 그 정적 파일의 경로(서버의 루트 폴더를 기준으로 한다)와 파일명을 호스트 뒤에 기술해야 하는데, 이것이 바로 `path`이다. 예를 들면 [http://naver.com](http://naver.com)/assets/data/data.json

자바스크립트를 활용하면 동적으로 서버에 정적/동적 데이터를 전부 요청할 수 있다(ajax, REST API).

이 모든 과정은 개발자 도구의 Network 패널에서 확인 가능한데, index.html뿐만 아니라 CSS, JS, 이미지, 폰트 파일도 전부 응답된 이유는 브라우저의 렌더링 엔진이 HTML(index.html)을 파싱하는 도중에 태그를 만나면 HTML 파싱을 일시 중단하고 해당 리소스 파일을 먼저 서버에 요청하기 때문이다.

### HTTP 1.1 vs HTTP 2.0

> HTTP/1.1
> 

커넥션당 하나의 요청, 하나의 응답만 처리 가능하다. 여러 개의 요청을 한 번에 보내는 것도 안 되고 여러 개의 응답을 한 번에 보내는 것도 안 된다. HTML문서 내 포함된 여러 리소스-link태그(CSS), img태그(이미지), script태그(자바스크립트)-요청/응답이 개별적으로 전송된다. 동시 전송 불가능 —> 리소스의 개수에 비례해 응답 시간 증가

> HTTP/2.0
> 

커넥션당 여러 개의 요청과 응답이 가능하다. 자세한 내용은 구글 참고

## 1. HTML 파싱 → DOM 생성

> DOM은 HTML을 파싱한 `트리 자료구조` 결과물이다.
> 

서버에서 받은 HTML은 문자열로 이루어진 순수한 텍스트이기 때문에, 이를 브라우저에 시각적인 픽셀로 렌더링하려면 HTML을 브라우저가 이해할 수 있는 자료구조, 객체(DOM, Document Object Model)로 변환하여 메모리에 저장해야 한다.

![browset](https://user-images.githubusercontent.com/97890886/168600399-3481d429-ffc8-4662-b8d5-16107ec61374.png)

1. 서버가 브라우저의 요청에 응답한다 : HTML 파일을 읽고 메모리에 저장 → `바이트`(2진수)로 응답
2. 브라우저가 받은 HTML 문서(바이트) — 인코딩(주로 UTF-8)—> `문자열`
3. 문자열—> `토큰`(문법적 의미를 갖는 최소 단위)
4. 토큰—각 토큰을 객체로 변환—> `노드`
5.  노드—각 노드(HTML 요소)의 상속 관계를 반영하여 트리 자료구조로 구성 —> `DOM`

## 2. CSS 파싱 → CSSOM 생성

렌더링 엔진은 HTML을 순차적으로 파싱하여 DOM을 만들어 가는데, 이 때 link태그나 style태그(CSS)를 만나면 DOM 생성을 중단하고 내부적으로 파싱(바이트→문자→토큰→노드→CSSOM)하여 CSSOM(CSS Object Model)을 생성한다. CSS도 DOM처럼 상속 관계를 구현한다. 그 후 다시 DOM을 이어서 생성한다.

## 3. 렌더 트리 생성

렌더링 엔진이 서버로부터 응답된 HTML과 CSS를 파싱하여 각각 생성한 DOM과 CSSDOM을 렌더링을 위하여 `렌더 트리(render tree)`로 결합한다.

렌더 트리는 렌더링을 위한 트리 구조의 자료구조이므로, 화면에 렌더링되지 않는(보이지 않는 meta 태그, script 태그 등)노드와 CSS에 의해 비표시(display:none 등)되는 노드들은 포함되지 않고 직접적으로 브라우저 화면에 렌더링되는(보이는) 노드만으로 구성된다.

## 4. 레이아웃 계산과 페인팅

이후 완성된 렌더 트리를 사용하여 HTML 요소의 레이아웃(위치, 크기 등)을 계산하고 —> 렌더 트리는 브라우저 화면에 페인팅(픽셀을 렌더링)된다.

일련의 과정은 단 한 번 실행되는 것이 아니며,

- 자바스크립트에 의한 DOM, CSSOM 수정(노드 추가/삭제)
- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
- HTML 요소의 레이아웃(위치, 크기 등)을 변경시키는 CSS 스타일 변경(width 요소 등)

다음과 같은 변동사항이 생기면 다시 렌더링되는데, 이러한 리렌더링 과정은 상당히 비효율적이기 때문에 최대한 억제하는 것이 좋다.

## 자바스크립트 파싱과 실행

> 소스코드 → 토큰 → AST → 바이트코드 —> 실행됨(by 인터프리터)
> 

렌더링 엔진이 위에서 설명한 과정(HTML 순차적 파싱)을 거치며 DOM을 생성해 나가던 중 script 태그를 만나면 CSS때와 동일하게 DOM 생성을 일시 중단하며, 자바스크립트 코드를 파싱하여 AST를 생성하기 위해 자바스크립트 엔진에 제어권을 넘긴다.

자바스크립트 엔진은

1. 자바스크립트 코드를 파싱하여—>저수준 언어(기계어)로 변환 및 실행하고
2. —>AST(추상적 구문 트리)를 생성
3. —>AST를 기반으로 중간 코드(바이트코드)를 생성 및 실행하여
4. —>최종적으로 인터프리터가 코드를 실행할 수 있도록 한다.

### 토크나이징(소스코드→토큰)

자바스크립트 소스코드(단순 문자열) —어휘(exical) 분석—> 토큰(문법적 의미를 갖는 코드의 최소 단위)

### 파싱(토큰→노드)

토큰들의 집합 —구문(syntax) 분석—> AST(추상적 구문 트리)

AST 는 인터프리터나 컴파일러뿐만 아니라 다양한 곳에서 사용된다(AST를 사용하여 트랜스파일러-Babel이나 TypeScript와 같은-를 구현할 수도 있다!) [https://astexplorer.net/](https://astexplorer.net/) 참고

### AST→바이트코드

AST가 바이트코드(인터프리터가 실행할 수 있는 중간 코드)로 변환되고 실행된다. 사용 빈도가 잦은 코드는 터보팬(TurboFan, 컴파일러)에 의해 최적화된 머신 코드(optimized nachine code)로 컴파일되어 성능을 최적화한다. 코드의 사용 빈도가 적어지면 다시 디옵티마이징(deoptimizing)한다.

# 리플로우와 리페인트

DOM은 DOM API(HTML 문서의 구조, 정보, 요소, 스타일 등을 전부 변경할 수 있는 프로그래밍 인터페이스)을 제공하며, 자바스크립트 코드에서 DOM을 사용하여 이미 생성된 DOM을 동적으로 조작할 수 있다.

자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 리플로우(레이아웃 재계산 : 노드 추가/삭제, 요소 크기/위치 변경, 윈도우 리사이징-뷰포트 변경-등 레이아웃에 영향을 주는 변경이 일어났을 경우 실행됨), 리페인트(재결합된 렌더 트리를 기반으로 다시 페인팅) 과정이 일어난다.

이 두 과정이 항상 순차적으로 일어나는 것은 당연히~ 아니다. 레이아웃에 영향이 없는 변경의 경우 리플로우는 건너뛰고 리페인트만 일어나게 된다.

# 자바스크립트 파싱에 의한 HTML 파싱 중단 억제하기

## script 태그를 body 태그의 가장 아래에 위치시키기

> 브라우저는 동기적(synchronous)이므로, script 태그의 위치는 중요한 의미를 갖는다.
> 

렌더링 엔진과 자바스크립트 엔진은 병렬적으로 파싱을 실행하지 않으며 직렬적으로 파싱을 수행한다. 순차적으로 코드를 실행하기 때문에 script 태그의 위치에 따라 HTML 파싱이 블로킹되어 DOM 생성이 지연될 수 있다 → script 태그의 위치가 중요하다.

> script 태그는 body 태그의 가장 아래에 위치시키는 것이 좋다.
> 
- DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 생길 수 있다
- 자바스크립트의 로딩/파싱/실행으로 HTML 렌더링이 지장받는 일이 생기지 않아 페이지 로딩 시간이 단축된다.

script 태그를 body 태그의 가장 아래에 위치시키면 자바스크립트가 실행될 시점에 이미 렌더링 엔진이 HTML 요소를 전부 파싱하여 DOM을 생성 완료한 이후이기 때문에 위와 같은 문제가 생길 우려가 없다.

## script태그의 어트리뷰트(속성) : async/defer 사용하기

문제를 근본적으로 해결하기 위해 HTML5부터 추가된 어트리뷰트 `async`와 `defer`을 사용해 보자.

async와 defer 어트리뷰트는 src 어트리뷰트를 통해 자바스크립트를 로드하는 경우에만 사용 가능하며(즉, src를 쓰지 않는 인라인 자바스크립트는 사용 불가능) HTML 파싱과 외부 자바스크립트 파일의 로드가 `비동기적(asynchronous)`으로 **동시에** 진행된다는 점에서는 유사하지만 자바스크립트의 실행 시점에서 차이가 있다.

### async 어트리뷰트

자바스크립트 파일 로드 작업이 완료된 직후 자바스크립트 파싱, 실행이 즉시 진행된다. script 태그 여러개로 자바스크립트 파일을 여러 개 불러온 경우, 의도한 순서가 있어도(그리고 그 순서대로 script 태그를 작성한 경우) 그냥 로드가 완료된 것부터 실행이 되어버리기 때문에 순서 보정이 필요한 경우에는 권장하지 않는다.

### defer 어트리뷰트

async와 달리, 자바스크립트의 파싱과 실행이 DOM 생성이 완료된 직후(HTML 파싱이 전부 완료된 직후)에 실행된다.
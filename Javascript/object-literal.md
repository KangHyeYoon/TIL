자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 모든 것이 객체이다. 즉, 원시 값을 제외한 나머지 함수, 배열, 정규 표현식 등도 전부 객체이다.

> 객체는
> 
- 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조
- `변경 가능한 값` mutable value

![object](https://user-images.githubusercontent.com/97890886/162573645-755c0ce7-f302-4ce0-aee7-d8b67063b27e.png)


# 프로퍼티와 메서드

- property : 객체의 상태를 나타내는 값 (data)
- method : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

프로퍼티는 객체 내부 데이터이며, 메서드는 객체 내부의 데이터(==프로퍼티)를 다루는 함수이다. 이처럼 객체는 `상태`와 `동작`을 하나의 단위로 구조화할 수 있다.

# 프로토타입 기반 객체지향 언어

자바스크립트는 `프로토타입 기반 객체지향 언어`이다.

> 클래스 기반 객체지향 언어
> 

클래스를 사전에 정의하고, 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다. 인스턴트란 클래스에 의해 생성되며 객체가 메모리에 실제로 존재하게 된 것에 초점을 맞춘 용어로, 클래스 기반에서의 객체는 클래스+인스턴트이다. 

> 프로토타입 기반 객체지향 언어
> 

클래스 기반과는 달리 다양한 객체 생성 방법을 지원한다.

- 객체 리터럴 {}
- 생성자 함수 Object
- 생성자 함수
- 메서드 Object.create
- 클래스(ES6~)

이 중 객체 리터럴은 가장 간단한 방법이다.

<aside>
❕ 리터럴이 뭔지 까먹으셨나요?

</aside>

리터럴 literal : 사람이 이해할 수 있는 문자, 약속된 기호 등을 사용하여 값을 생성하는 표기법. 즉 객체 리터럴은 객체를 생성하기 위한 표기법이나 다름없다.

# 객체 리터럴

> 정의하기
> 

{ } 사이에 0개 이상의 프로퍼티를 정의한다. 빈 객체도 만들 수 있다. 변수에 할당되는 시점에 자바스크립트 엔진이 객체 리터럴을 해석해 객체를 생성한다.

> 장점
> 

객체를 생성하기 위해 클래스를 먼저 정의하고, new 연산자와 함께 생성자를 호출할 필요가 없다. → 자바스크립트만의 유연성과 강력함 (나머지 방법은 전부 함수를 사용하게 될 것이다.)

```jsx
var person = {
    name: `kang`,
    age: 22,
    output: function() {
        console.log(`이름은 ${name}이고 나이는 ${age}입니다`);
    }
}

console.log(typeof person);     // object
console.log(person);    // { name: 'kang', age: 22, output: [Function: output] }
```

> 주의사항
> 

객체 리터럴의 중괄호는 코드 블록이 아니고, 값으로 평가되는 표현식이므로 `세미콜론`을 꼭 붙여야 한다!

# 프로퍼티

- 객체란 프로퍼티의 집합
- 키와 값으로 구성. 구분은 쉼표

> 키
> 

프로퍼티 값에 접근할 수 있는 이름. 식별자의 역할을 한다. 식별자 네이밍 규칙을 지키는 것을 권장한다. (지키지 않아도 상관없지만, 따옴표로 묶어 정의해줘야 하므로 상당히 귀찮음)

```jsx
// 일반적인 프로퍼티 키 (유효한 문자열 or 심볼 값)
var Hi = {
    dailyHi : 'hello',
};

// 빈 문자열 프로퍼티 키
var foo = {
    '': '',
};

// 문자열, 심볼 외의 값 프로퍼티 키
// 암묵적 타입 변환 -> 문자열이 된다
var goo = {
    0 : 1,
    1 : 2,
    2 : 3,
};

// 프로퍼티 키 중복 선언
// 나중에 선언한 프로퍼티가 덮어쓴다
var loo = {
    name: 'kang',
    name: 'lee',
};
console.log(loo)    // {name: "lee"}
```

문자열(또는 문자열로 평가할 수 있는 표현식)으로 프로퍼티 키를 동적으로 생성할 수도 있다.

```jsx
var obj = {};
var key = 'Hello';

// ES5
obj[key] = 'World';

// ES6
obj = {[key] : 'world'};

console.log(obj);   // { Hello: 'world' }
```

> 값
> 

자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다.

# 프로퍼티 접근

> 마침표 표기법 dot notation
> 

. 접근 연산자 사용

> 대괄호 표기법 bracket notation
> 

[ ] 접근 연산자 사용.

- 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 경우, 반드시 대괄호 표기법을 사용할 것
- 내부에 지정하는 프로퍼티 키는 반드시 `따옴표로 감싼 문자열`이어야 한다. 따옴표가 없으면 자바스크립트 엔진은 이를 식별자로 해석함
- 객체에 존재하지 않는 프로퍼티에 접근할 시 undefined 반환 (Error X)

```jsx
// 식별자 네이밍 규칙을 지키지 않은 프로퍼티 키들
var person = {
    'last-name': 'Yoon',
    1: 10,
};

person.'last-name';     // Error : 정의되지 않은 문자열(식별자 필요)
person['last-name'];

person.1;       // Error : 정의되지 않은 키워드/식별자
person.'1';     // Error : 정의되지 않은 문자열(식별자 필요)
person[1];
person['1'];
```

# 프로퍼티 관리

## 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.

```jsx
var person = {
    name: 'Kang',
};

person.name = 'lee';

console.log(person['name']);    // lee
```

## 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가된다.

```jsx
var person = {
};

person.age = 22;

console.log(person['age']);    // 22
```

## 프로퍼티 삭제

delete 연산자로 프로퍼티를 삭제한다. 존재하지 않는 프로퍼티를 지정해도 에러 없이 무산된다.

```jsx
var person = {
    name: 'Kang',
};

person.age = 22;
delete person['name'];

console.log(person);    // { age: 22 }
```

# 메서드

자바스립트의 함수는 (일급)객체이므로, 값으로 취급할 수 있기 때문에 프로퍼티 값으로도 사용할 수 있다. 프로퍼티 값이 함수일 때, 이를 일반 함수와 구분하기 위해 메서드 method 라고 부른다.

# ES6: 객체 리터럴 확장 기능

## 프로퍼티 축약 표현

프로퍼티 값으로 변수(정확히 말하면 변수에 할당된 값을 변수라는 껍데기로 사용)를 사용하는 경우, 프로퍼티 키와 변수의 이름이 같을 때 `프로퍼티 키를 생략`할 수 있다.  생략된 프로퍼티 키는 변수의 이름으로 자동 생성된다.

```jsx
// ES5
var year = 2022;
var age = 22;

var obj = {
    year: year,
    age: age,
};

console.log(obj);   // { year: 2022, age: 22 }

// ES6
let year2 = 2022, age2 = 22;

const obj2 = {year2, age2};

console.log(obj);   // { year: 2022, age: 22 }
```

## 계산된 프로퍼티 이름

아까 살펴봤듯이, 프로퍼티 키는 유연하게 동적으로 생성할 수 있다.

- 프로퍼티 키를 `문자열`로 평가할 수 있는 표현식으로 만들 때만 가능
- `[ ] 연산자`를 사용할 것

```jsx
var obj = {};

var key = 'loop';
var i = 10;

// ES5
obj[key + '-' + ++i] = i;
obj[key + '-' + ++i] = i;
obj[key + '-' + ++i] = i;

// ES6
obj = {[key] : 'world'};

console.log(obj);   // { Hello: 'world' }
```

만약, 계산식을 포함하여 프로퍼티 키를 동적으로 만들고 싶다면? 본 예시에서는 loop-10부터 시작하여 11, 12... 까지 증감연산식을 포함한 프로퍼티 이름으로 프로퍼티 키를 동적 생성해 보았다.

```jsx
// 계산식이 포함된 프로퍼티 이름으로 프로퍼티 키 동적 생성

// ES5 : 객체 리터럴 외부에서 [] 사용하여 생성
var key = 'loop';
var i = 10;

var obj = {};

obj[key + '-' + ++i] = i;
obj[key + '-' + ++i] = i;
obj[key + '-' + ++i] = i;

// ES6 : 객체 리터럴 내부에서도 생성 가능. 가독성(블록화) 좋음
let i = 10;
const key = 'loop';

const obj = {
    [`${key}-${++i}`] : i,
    [`${key}-${++i}`] : i,
    [`${key}-${++i}`] : i,
}

// 결과
console.log(obj);   // { 'loop-11': 11, 'loop-12': 12, 'loop-13': 13 }
```

## 메서드 축약 표현

프로퍼티 값으로 ‘함수(function)’를 `할당`하여 메서드를 정의하는 ES5와 달리, ES6은 프로퍼티 값으로 할당( : 연산자 사용)하는 형식이 아닌, 일반적인 함수처럼 표기하여 `function 키워드를 생략`한다. 단, ES6의 축약 표현으로 정의된 메서드는 할당된 함수와 다르네 동작함에 주의하자.

```jsx
// ES5
var obj = {
    name: 'kang',
    hello: function() {
        console.log('hello, ' + this.name);
    }
};

obj.hello();    // hello, kang

// ES6
const obj2 = {
    name2: 'lee',
    hi() {
        console.log(`hello, ${this.name2}`);
    }
}

obj2.hi();      // hello, lee
```